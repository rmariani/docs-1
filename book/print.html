<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Fluence book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li><a href="introduction/overview.html"><strong aria-hidden="true">1.1.</strong> Overview</a></li><li><a href="introduction/motivation.html"><strong aria-hidden="true">1.2.</strong> Motivation</a></li><li><a href="introduction/incentive_model.html"><strong aria-hidden="true">1.3.</strong> Incentive model</a></li></ol></li><li><a href="quickstart/index.html"><strong aria-hidden="true">2.</strong> Quickstart</a></li><li><ol class="section"><li><a href="quickstart/backend.html"><strong aria-hidden="true">2.1.</strong> Developing the backend</a></li><li><ol class="section"><li><a href="quickstart/backend.html"><strong aria-hidden="true">2.1.1.</strong> Rust</a></li><li><a href="quickstart/backend-assemblyscript.html"><strong aria-hidden="true">2.1.2.</strong> AssemblyScript</a></li></ol></li><li><a href="quickstart/publish.html"><strong aria-hidden="true">2.2.</strong> Publishing the backend app</a></li><li><a href="quickstart/web.html"><strong aria-hidden="true">2.3.</strong> Developing the web app</a></li><li><a href="quickstart/ipfs-website.html"><strong aria-hidden="true">2.4.</strong> Publishing the web app to IPFS</a></li><li><a href="quickstart/recap.html"><strong aria-hidden="true">2.5.</strong> Recap</a></li></ol></li><li><a href="backend/index.html"><strong aria-hidden="true">3.</strong> Backend guide</a></li><li><ol class="section"><li><a href="backend/rust/sdk.html"><strong aria-hidden="true">3.1.</strong> Rust</a></li><li><ol class="section"><li><a href="backend/rust/sdk.html"><strong aria-hidden="true">3.1.1.</strong> SDK overview</a></li><li><a href="backend/rust/best_practices.html"><strong aria-hidden="true">3.1.2.</strong> Best practices</a></li></ol></li><li><a href="backend/c_cpp/sdk.html"><strong aria-hidden="true">3.2.</strong> C/C++</a></li><li><ol class="section"><li><a href="backend/c_cpp/sdk.html"><strong aria-hidden="true">3.2.1.</strong> SDK overview</a></li><li><a href="backend/c_cpp/best_practices.html"><strong aria-hidden="true">3.2.2.</strong> Best practices</a></li></ol></li><li><a href="soon.html"><strong aria-hidden="true">3.3.</strong> AssemblyScript: soon</a></li><li><a href="backend/debugging.html"><strong aria-hidden="true">3.4.</strong> Debugging</a></li><li><a href="backend/internals.html"><strong aria-hidden="true">3.5.</strong> Internals</a></li><li><a href="soon.html"><strong aria-hidden="true">3.6.</strong> HowTo: common patterns</a></li></ol></li><li><a href="frontend/index.html"><strong aria-hidden="true">4.</strong> Frontend guide</a></li><li><ol class="section"><li><a href="frontend/javascript.html"><strong aria-hidden="true">4.1.</strong> Javascript Client</a></li><li><a href="frontend/http.html"><strong aria-hidden="true">4.2.</strong> HTTP protocol</a></li></ol></li><li><a href="nodes.html"><strong aria-hidden="true">5.</strong> Running Fluence nodes</a></li><li><a href="cli.html"><strong aria-hidden="true">6.</strong> Command-line interface</a></li><li><a href="examples.html"><strong aria-hidden="true">7.</strong> Key examples</a></li><li><a href="project.html"><strong aria-hidden="true">8.</strong> Project status</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Fluence book</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#introduction" id="introduction"><h1>Introduction</h1></a>
<a class="header" href="#what-is-fluence" id="what-is-fluence"><h2>What is Fluence?</h2></a>
<p>Fluence is an efficient trustless computation platform that allows to achieve few seconds request processing latency and cost efficiency similar to traditional cloud computing. To run computations, Fluence uses a WebAssembly virtual machine, which allows to deploy into the decentralized environment applications written in multiple programming languages.</p>
<a class="header" href="#what-can-be-built-with-fluence" id="what-can-be-built-with-fluence"><h2>What can be built with Fluence?</h2></a>
<p>Fluence can be used as a general purpose backend engine for decentralized applications. Because of its cost efficiency, developers generally do not have to worry much about low-level code optimization. Existing software packages can be ported to Fluence as is, once they are compiled into WebAssembly.</p>
<a class="header" href="#decentralized-databases" id="decentralized-databases"><h4>Decentralized databases</h4></a>
<p>As an <a href="https://github.com/fluencelabs/tutorials/tree/master/llamadb">example</a>, we have ported an existing toy SQL database <a href="https://github.com/nukep/llamadb">LlamaDB</a> to run in the decentralized environment by making just a few modifications and compiling it into WebAssembly.</p>
<p>We expect it should not be extremely difficult to port an existing database such as SQLite or RocksDB to Fluence. Deployed, this database could serve frontends of user-facing decentralized applications.</p>
<p>This, coupled with decentralized storages such as IPFS or Swarm could enable fully decentralized applications. Such applications would use a decentralized storage to store static data, and a decentralized database running on top of Fluence – to serve dynamic client requests.</p>
<a class="header" href="#gambling-applications" id="gambling-applications"><h4>Gambling applications</h4></a>
<p>Simple dice games or roulette can be ported to Fluence fairly easily. However, at the current moment Fluence is not able to run by itself <a href="https://en.wikipedia.org/wiki/Perfect_information">imperfect information games</a> such as Texas Holdem poker or Guess the Number. The reason is that full game state can be read by nodes running the backend, and Fluence does not have privacy-preserving computations built in into its SDK.</p>
<p>We expect, however, that approaches such as <a href="https://ethereum.stackexchange.com/questions/376/what-are-effective-and-secure-ways-of-shuffling-a-deck-of-cards-in-a-contract/758">decentralized card deck shuffling</a> can be employed to port certain imperfect information games to the Fluence network. In the meanwhile we have prepared a <em><a href="https://github.com/fluencelabs/tutorials/tree/master/guessing-game">broken implementation</a></em> of Guess the Number game ;)</p>
<a class="header" href="#games" id="games"><h4>Games</h4></a>
<p>Perfect information games can be easily built on top of Fluence. Think of chess, Go, rock–paper–scissors, games similar to Dungeons and Dragons, or roll-and-move board games. We have prepared a <a href="https://github.com/fluencelabs/tutorials/tree/master/tic-tac-toe">tic-tac-toe</a> example to play with. Collectible decentralized applications can be launched on Fluence as well.</p>
<a class="header" href="#how-does-fluence-work" id="how-does-fluence-work"><h2>How does Fluence work?</h2></a>
<p>In order to reach low latency and high throughput, Fluence splits network nodes into two layers: the <em>real-time processing layer</em> and the <em>batch validation layer</em>.</p>
<p>The real-time processing layer is able to promptly serve client requests, but provides only moderate security guarantees that returned responses are correct. Later, the batch validation layer additionally verifies returned responses, and if it is found that some of the responses were incorrect, offending real-time nodes lose their deposits.</p>
<p>In this section we provide brief Fluence overview and discuss reasons to have delayed verification. We also consider Fluence basic incentive model.</p>
<a class="header" href="#links" id="links"><h2>Links</h2></a>
<ul>
<li><a href="http://fluence.network/">Fluence Labs site</a></li>
<li><a href="https://discordapp.com/invite/AjfbDKQ">Discord</a></li>
<li><a href="https://github.com/fluencelabs/fluence">Github</a></li>
<li><a href="https://github.com/fluencelabs/tutorials/">Tutorials</a></li>
</ul>
<a class="header" href="#overview" id="overview"><h1>Overview</h1></a>
<p>The Fluence network consists of nodes performing computations in response to transactions sent by external clients. Algorithms specifying those computations are expressed in the WebAssembly bytecode; consequently, every node willing to participate in the network has to run a WebAssembly virtual machine.</p>
<p>Independent developers are expected to implement a backend package handling client transactions in a high-level language such as C/C++, Rust, or TypeScript, compile it into one or more WebAssembly modules, and then deploy those modules to the Fluence network. The network then takes care of spinning up the nodes that run the deployed backend package, interacting with clients, and making sure that client transactions are processed correctly.</p>
<a class="header" href="#architecture" id="architecture"><h2>Architecture</h2></a>
<p>Two major layers exist in the Fluence network: the real-time processing layer and the batch validation layer. The former is responsible for direct interaction with clients; the latter, for computation verification. In other words, real-time processing is the speed layer and batch validation is the security layer. The network also relies on Ethereum (as a secure metadata storage and dispute resolution layer) and Swarm (as a data availability layer)</p>
<div style="text-align:center">
<kbd>
<img src="../images/architecture_overview.png" width="666px"/>
</kbd>
<br><br><br>
</div>
<a class="header" href="#components" id="components"><h2>Components</h2></a>
<a class="header" href="#real-time-processing-layer" id="real-time-processing-layer"><h3>Real-time processing layer</h3></a>
<p>The real-time processing layer consists of multiple real-time clusters, which are stateful and keep locally the state required to serve client requests. Each cluster is formed by a few real-time worker nodes that are responsible for running particular backend packages and storing related state data. Workers in real-time clusters use Tendermint to reach BFT consensus and an interim metadata storage (built on top of a DHT such as Kademlia) to temporarily store consensus metadata before it is compacted and uploaded to the Ethereum blockchain.</p>
<div style="text-align:center">
<kbd>
<img src="../images/rt_overview.png" width="736px"/>
</kbd>
<br><br><br>
</div>
<p>To deploy a backend package to the Fluence network, the developer first has to allocate a cluster to run the package. Once the package is deployed, those functions that are exposed as external can be invoked by client transactions. If the package is no longer needed, the developer is able to terminate the cluster.</p>
<p>Developers possess significant control over real-time clusters: they are able to specify the desired cluster size and how much memory each node in the cluster should allocate to store the state. If one of the workers in the cluster is struggling, the developer who has allocated the cluster can replace this worker with a more performant one.</p>
<p>Real-time clusters are able to promptly respond to client requests, but those responses carry only moderate security guarantees when a significant fraction of network nodes are malicious. Because real-time clusters are formed by just a few worker nodes, they can tolerate only few malicious nodes, which leaves a non-trivial chance that a real-time cluster might be completely dominated by attackers. Therefore, an additional level of verification is required for computations performed by real-time clusters.</p>
<a class="header" href="#batch-validation-layer" id="batch-validation-layer"><h3>Batch validation layer</h3></a>
<p>To keep real-time clusters in check, the batch validation layer separately verifies all performed computations. This layer is composed of independent batch validators, which are stateless and have to download the required data before performing verification. In order to support this, every real-time cluster is required to upload the history of received transactions and performed state transitions to Swarm. Because Tendermint organizes transactions into blocks that each carry the hash of the state obtained after the previous block execution, real-time clusters upload transactions to Swarm in blocks as well.</p>
<p>Later on, batch validators replay fragments of transaction history, which are composed of one or more blocks, and challenge state transitions that they have deemed incorrect through the dispute resolution layer. If one of the state transitions is not correct, it takes only a single honest validator to challenge this and penalize the real-time cluster that performed the transition.</p>
<div style="text-align:center">
<kbd>
<img src="../images/validation_overview.png" width="651px"/>
</kbd>
<br><br><br>
</div>
<p>Developers do not have any control over batch validators beyond deciding how much budget is carved out for batch validation – i.e., how many batch validations should happen for the fragment of transaction history once it is uploaded to Swarm. Furthermore, the batch validator that verifies any specific history fragment is chosen randomly out of all batch validators in the network in order to prevent possible cartels.</p>
<p>Batch validators compact the transaction history and reduce Swarm space usage by uploading intermediate state snapshots to Swarm. Once a transaction history fragment has been verified a sufficient number of times, it is dropped, leaving only the corresponding snapshot.</p>
<div style="text-align:center">
<kbd>
<img src="../images/validation_state.png" width="705px"/>
</kbd>
<br><br><br>
</div>
<a class="header" href="#dispute-resolution-layer" id="dispute-resolution-layer"><h3>Dispute resolution layer</h3></a>
<p>We have already mentioned that batch validators are able to dispute state transitions. This ability is not exclusive to batch validators: a real-time worker can submit a dispute if it disagrees with another real-time worker on how the state should be updated. However, such disputes normally arise only between workers that belong to the same cluster – other real-time workers simply do not carry the required state.</p>
<p>No matter which node has submitted the dispute, it is resolved with the aid of an external authority. The Fluence network uses a specially developed Ethereum smart contract named Arbiter as this authority. Because Ethereum is computationally bounded and thus unable to repeat the entire computation to verify state transitions, a verification game mechanism is used to find the first WebAssembly instruction that produced the diverging states. Only this instruction with the relevant portion of the state is then submitted to the Arbiter contract, which then makes its final decision as to which node performed the incorrect state transition.</p>
<p>Every node in the network is required to put down a significant security deposit before performing computations. If it is found that a node has behaved incorrectly, its deposit is slashed. Assuming that potential adversaries are financially restricted, this reduces the number of cases where a client might receive an incorrect response.</p>
<a class="header" href="#data-availability-layer" id="data-availability-layer"><h3>Data availability layer</h3></a>
<p>The Swarm receipts mechanism is used to make sure that the fragments of transaction history uploaded by the real-time clusters do not disappear before the batch validators replay and verify them. The Swarm receipt is a confirmation from the Swarm node that it is responsible for the specific uploaded data. If the Swarm node is not able to return the data when requested, its deposit is slashed, which prevents Swarm from losing potentially incriminating data.</p>
<a class="header" href="#secure-metadata-storage" id="secure-metadata-storage"><h3>Secure metadata storage</h3></a>
<p>Deposits placed by Fluence network nodes, Swarm receipts issued for transaction history fragments, and metadata entries related to the batch validation and real- time cluster compositions are stored in the Ethereum blockchain. For the sake of simplicity in this paper, we will assume that the Arbiter contract holds this data in addition to its dispute resolution responsibilities.</p>
<a class="header" href="#motivation" id="motivation"><h1>Motivation</h1></a>
<p>To understand the reason behind having two noticeably different layers, we need to recall their properties. Real-time workers are stateful, which considerably improves response latencies because they do not have to download the required state data to perform computations.
As an example, assume that we are building a decentralized SQL database that should support an indexed access to data. Complex queries such as the one listed below often require traversal of multiple indices, which are often implemented as B-trees.</p>
<pre><code class="language-sql">SELECT
    DATE(ts) AS date,
    AVG(gas_price * gas_used) AS tx_cost
FROM transactions tx WHERE
    tx.to IN (SELECT address
              FROM contracts
              WHERE name = ’CryptoDolphins’) 
GROUP BY DATE(ts)
</code></pre>
<p><em>Example query to blockchain data.</em></p>
<p>To traverse a B-tree, we need to sequentially fetch its nodes that satisfy the query conditions. It is not possible to retrieve the required B-tree nodes all at once because the next node to fetch can be determined only by matching the parent B-tree node against the query. If an index is stored externally in a decentralized storage such as IPFS or Swarm, this means that multiple network roundtrips must be performed between the machine performing the computations and the data storage, which significantly increases latency.</p>
<p>Other algorithms, especially those requiring irregular access to data, could benefit from storing their data locally as well. However, data locality significantly increases the economic barrier to joining a real-time cluster because a worker willing to participate in the cluster has to download the current state first. Consequently, this motivates workers to remain in the cluster and thus cluster compositions do not change much over time.</p>
<p>This means that malicious real-time workers in the cluster might form a cartel to produce incorrect results. Without batch validation, every node in the real-time cluster knows it will be verified only by its peers, which are known in advance because clusters are tightly connected. Consequently, malicious nodes can, for example, exploit the following strategy: use a special handshake to recognize other malicious nodes in the cluster and start producing incorrect results if they account for at least \(\frac{2}{3}\) of the total number of nodes (so they can reach BFT consensus without talking to the rest of the cluster); otherwise, work honestly. This strategy is virtually impossible to catch without external verification.</p>
<p>Furthermore, because real-time clusters are supposed to be small enough to be cost-efficient, the probability that malicious nodes will take over a cluster is significant. For example, for a network where 10% of all nodes are malicious, a real-time cluster that consists of 7 workers independently sampled from the network has approximately a 1.8 · 10<sup>−4</sup> chance to have at least \(\frac{2}{3}\) malicious nodes.</p>
<p>To counteract this, the batch validation layer provides external verification. Nodes performing batch validation are chosen randomly, which means real-time nodes do not know beforehand which validator will be verifying them and thus cannot collude with the validator in advance.</p>
<p>Batch validation also decreases the probability that an intentional mistake made by a real-time cluster will never get noticed. Assume that in the same network where 10% of all nodes are malicious, we spun a real-time cluster of 4 workers and allocated a budget for 3 batch validations.</p>
<p>In this setup, a mistake can go unnoticed only if malicious actors comprise at least \(\frac{2}{3}\) of the realtime workers and all of the batch validators that verified the transaction history. The chance of this happening is ≈ 3.7 · 10<sup>−6</sup>, which is two orders of magnitude less than in the case where the entire budget was spent on the real-time cluster only.</p>
<p>We also expect that in the presence of batch validators, the fraction of malicious nodes in the network will drop significantly below 10%, because every time a malicious action is caught, the node that performed it loses its deposit and thus leaves the network.</p>
<a class="header" href="#incentive-model" id="incentive-model"><h1>Incentive model</h1></a>
<p>Fluence uses a concept similar to Ethereum gas to track computational efforts. With few exceptions, every WebAssembly instruction has a predefined associated cost, which is named fuel to avoid confusion with Ethereum gas. The fuel required to perform a computation is roughly proportional to the total sum of fuel amounts assigned to instructions in the computation execution trace.</p>
<p>When it comes to storage usage accounting, Fluence rules differ significantly from Ethereum. Ethereum instructions for interacting with persistent storage require the client to pay a one-time fee – which is significant – to compensate for a certain amount of future expenses that will be incurred in storing the information. For example, <code>SSTORE</code> (the instruction that is used to save a word to the persistent storage) costs 20,000 gas, which is a few orders of magnitude more than the cost of basic instructions such as <code>POP</code>, <code>ADD</code>, or <code>MUL</code>, which require 2–5 gas.</p>
<p>While this approach has been working fairly well for Ethereum, we think that adapting it to the Fluence network – the aim of which is achieving cost-efficiency comparable to traditional clouds – is problematic. In conventional backend software, it is common to update an on-disk or in-memory state without worrying that the performed update costs considerably more than other operations. In order to easily port existing software to Fluence, we need to provide developers a method that does not require them to fundamentally modify the code being ported.</p>
<p>Another reason to reconsider storage accounting is that execution of WebAssembly instructions and provision of data storage are quite different. If we say that network nodes are compensated for the performed work, then the total difficulty of processed instructions indeed defines an amount of the work performed. However, allocating a megabyte of storage is not <em>work</em> – it is <em>power</em>. Only after a node has kept a megabyte of data in storage for a certain time can we estimate how much work it has performed: <em>work</em> = <em>power</em> · <em>time</em>.</p>
<p>When a client pays a one-time upfront fee to upload their data, there is no way for the network node responsible for its storage to know how long the data will be stored. No matter how large the upfront fee is, it is possible that expenses required to store the data will exceed this fee, leaving the financial burden on the node. This means that a different storage accounting approach must be developed for the Fluence network, which we propose and discuss below.</p>
<p><strong>Rewards accounting.</strong> To counteract the aforementioned issues, various storage rent fees were proposed for Ethereum, including requiring clients to pay a fee to renew their storage every time they issue a transaction. However, to bring the developer experience as close as possible to traditional backend software, in the Fluence network, the developer is the only party finally responsible for compensating network nodes.</p>
<p>Fluence nodes are compensated for the computational difficulty of executed WebAssembly instructions and for the storage space allocated for a specific period of time. Because different hardware might need different time to execute the same program, computational difficulty is used as a sub- stitution for time. In other words, once a block of client transactions is processed and the fuel <em>φ</em> required to process it is counted, this fuel is transformed into the standard time <em>t</em><sub>std</sub> by multiplying it by the network-wide scaling constant <em>c</em><sub>time/fuel</sub>:</p>
<p><center>
<em>t</em><sub>std</sub> = <em>c</em><sub>time/fuel</sub> · <em>φ</em>
<br><br>
</center></p>
<p>To estimate the total node reward <em>υ</em>, two more scaling constants are introduced: <em>c</em><sub>υ/fuel</sub> converts spent units of fuel into the network currency; <em>c</em><sub>υ/spacetime</sub> does the same with the unit of storage space allocated for the unit of time. does the same with storage space per time. Assuming that the size of the allocated storage space is denoted by <em>ω</em>, the total node reward is computed as:</p>
<p><center>
<em>υ</em> = <em>c</em><sub>υ/fuel</sub> · <em>φ</em> + <em>c</em><sub>υ/spacetime</sub> · <em>ω</em> · <em>t</em><sub>std</sub>
<br><br>
</center></p>
<p>It should be noted that contrary to the system used by Ethereum where a client is able to choose a different gas price for every transaction, the scaling constants <em>c</em><sub>time/fuel</sub>, <em>c</em><sub>υ/fuel</sub>, and <em>c</em><sub>υ/spacetime</sub> are fixed for the entire Fluence network. One reason for this design is that batch validators are selected randomly and are not able to choose the computations they are going to verify.</p>
<p>By allowing clients or developers to choose their compensation level, batch validators might be forced to perform complex computations for an unreasonably low reward. To prevent this, scaling constants are periodically updated, similar to how mining difficulty changes in Ethereum. If there is not enough supply, the network-wide compensation level increases; conversely, if there is not enough demand, the compensation level drops.</p>
<p><strong>Dummy transactions.</strong> Because time is counted only for performed computations, simply storing the state without processing transaction blocks does not ensure any compensation to real-time workers. Therefore, in cases where incoming client transactions are rare, it is possible that the block creation rate will be low and thus low-demand backends will spend lots of time storing the state between the blocks. This time will never be compensated; workers running such low-demand backends might spend far more resources to store the state than their total compensation will be.</p>
<p>To offset this, real-time workers are allowed to send dummy transactions to themselves; the fuel required to process such dummy transactions is accounted for in the same way as the fuel required to process client transactions. This way, even if the client transaction volume is low, real-time workers will be compensated proportionally to the (real-world) time they have been running a certain backend deployment.</p>
<p>Batch validators, however, are not affected by this issue because they do not have to wait for incoming transactions and new blocks. A batch validator replays a fragment of transaction history at the maximum rate it is able to perform; once it completes the processing of the fragment, it moves to the next fragment. Additionally, for the same amount of work (which is defined by used fuel), real-time workers and batch validators are compensated evenly, which makes both options equally attractive to miners. Therefore, no special mechanism to recompense batch validators exists in the Fluence network.</p>
<p>Because different hardware can process transactions at different rates, it might happen that a very fast real-time cluster will be able to produce and process dummy transactions so fast that the compensation from the developer will become unexpectedly high. To mitigate this, in addition to being able to set the size of the storage space <em>ω</em>, developers have the ability to set the maximum fuel amount <em>φ</em><sub>max</sub> that real-time workers are allowed to spend per unit of time.</p>
<p>This allows a developer to budget how much will be spent on computations performed by the Fluence network in the next day, week, or month. Additionally, it lets real-time workers plan how much capacity they should allocate for transaction processing performed by the backend deployed by that developer.</p>
<p>We should note that it is possible for ill-disposed real-time workers to process only self-created dummy transactions – and none sent by clients. While we do not discuss a detailed mechanism to combat such behavior in this paper, we should note that a developer monitoring the use of the deployed backend will be able to notice a drop in the ratio between client and dummy transactions. In this case, the developer can either replace misbehaving real-time workers with other network nodes, or reduce the amount of fuel <em>φ</em><sub>max</sub> that the real-time cluster is allowed to spend per unit of time.</p>
<p><strong>Client billing.</strong> As we have previously mentioned, developers are exclusively responsible for paying out rewards to the Fluence network nodes. Because miners’ compensation is proportional to used fuel and allocated storage space, developers are directly incentivized to write efficient backends.</p>
<p>Generally, clients are not responsible for making any payments to network nodes. Nevertheless, different external monetization schemes are possible for reimbursing developers. The Fluence network does not prescribe an exact monetization scheme; however, it might provide some of the most common schemes through extension packages.</p>
<p>For example, one developer might allow only those clients from a whitelist to interact with the deployed backend, charging a flat rate to add a client to that whitelist; another developer might charge clients a fixed fee per each submitted transaction. It might also be possible for clients to pay no explicit fee while the developer uses their personal funds to cover the miners’ expenses.</p>
<a class="header" href="#quickstart" id="quickstart"><h1>Quickstart</h1></a>
<p>This document will guide you through the three major steps of development with Fluence.</p>
<p>You will develop a two-tiered web application with the Rust backend and the JavaScript frontend. While the architecture of this application resembles a conventional centralized one, the backend will get magically decentralized and will run on top of the Fluence network.</p>
<p>First, you will use the Fluence Rust SDK to develop the backend and compile it to a WebAssembly package. After that, to deploy the obtained backend package to the Fluence network, you will upload it to IPFS and publish the IPFS reference to the Fluence smart contract. Finally, you will build the frontend which will interact with the backend running in the Fluence network.</p>
<p>Should you have any questions, feel free to join our <a href="https://discordapp.com/invite/AjfbDKQ">Discord</a>!</p>
<a class="header" href="#developing-the-backend-app" id="developing-the-backend-app"><h1>Developing the backend app</h1></a>
<p>Fluence runs WebAssembly programs, so it is possible to build a Fluence backend in any language that targets WebAssembly. In this guide we will use Rust as a language of choice.</p>
<p>First you will build a hello world Rust app, adapt it to Fluence, and then compile it to WebAssembly.</p>
<a class="header" href="#setting-up-rust" id="setting-up-rust"><h2>Setting up Rust</h2></a>
<p>Let's get some Rust!</p>
<p>Install the Rust compiler:</p>
<pre><code class="language-bash"># installs the Rust compiler and supplementary tools to `~/.cargo/bin`
~ $ curl https://sh.rustup.rs -sSf | sh -s -- -y
info: downloading installer
...
Rust is installed now. Great!
To configure your current shell run source $HOME/.cargo/env
</code></pre>
<p>Let's listen to the installer and configure your current shell:<br />
<small>(new shell environments should pick up the right configuration automatically)</small></p>
<pre><code class="language-bash">~ $ source $HOME/.cargo/env
&lt;no output&gt;
</code></pre>
<p>After that, we need to install the nighly Rust toolchain:<br />
<small>(Fluence Rust SDK requires the nightly toolchain due to certain memory operations)</small></p>
<pre><code class="language-bash">~ $ rustup toolchain install nightly
info: syncing channel updates ...
...
  nightly-&lt;arch&gt; installed - rustc 1.34.0-nightly (57d7cfc3c 2019-02-11)
</code></pre>
<p>Let's check that the nightly toolchain was installed successfully:</p>
<pre><code class="language-bash">~ $ rustup toolchain list | grep nightly
# the output should contain the nighly toolchain
...
nightly-&lt;arch&gt;
</code></pre>
<p>To compile Rust to WebAssembly, we also need to add the <code>wasm32</code> compilation target:</p>
<pre><code class="language-bash"># install target for WebAssembly
~ $ rustup target add wasm32-unknown-unknown --toolchain nightly
info: downloading component 'rust-std' for 'wasm32-unknown-unknown'
info: installing component 'rust-std' for 'wasm32-unknown-unknown'
</code></pre>
<p>Finally, let's check that everything was set up correctly and compile a sample Rust code:</p>
<pre><code class="language-bash"># create a simple program that always returns 1
~ $ echo &quot;fn main(){1;}&quot; &gt; test.rs

# compile it to WebAssembly using rustc from the nightly toolchain
~ $ rustup run nightly rustc --target=wasm32-unknown-unknown test.rs
&lt;no output&gt;

# check that the test.wasm output file was created
~ $ ls -lh test.wasm
-rwxr-xr-x  1 user  user   1.4M Feb 11 11:59 test.wasm
</code></pre>
<p>If everything looks similar, then it's time to create a Rust hello-world project!</p>
<a class="header" href="#creating-an-empty-rust-package" id="creating-an-empty-rust-package"><h2>Creating an empty Rust package</h2></a>
<p>Let's create a new empty Rust package:</p>
<pre><code class="language-bash"># create empty Rust package
~ $ cargo +nightly new hello-world --edition 2018
Created binary (application) `hello-world` package

# go to the package directory
~ $ cd hello-world
~/hello-world $
</code></pre>
<p>More info on creating a new Rust project can be found in the Rust <a href="https://doc.rust-lang.org/cargo/guide/creating-a-new-project.html">Cargo book</a>.</p>
<a class="header" href="#optional-creating-a-hello-world-rust-application" id="optional-creating-a-hello-world-rust-application"><h2>[Optional] Creating a Hello World Rust application</h2></a>
<p>If you are already familiar with Rust, feel free to skip this section.</p>
<p>Let's write some code: our backend should receive a user name from the program input, and then print a greeting.</p>
<p>Take a look at <code>src/main.rs</code>:</p>
<pre><code class="language-bash">~/hello-world $ cat src/main.rs
</code></pre>
<p>You will see the following code, which should be there by default and almost does what we need:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Open <code>src/main.rs</code> in any editor, delete all existing code, and paste the following:</p>
<pre><pre class="playpen"><code class="language-rust">use std::env;

fn greeting(name: String) -&gt; String {
    format!(&quot;Hello, world! -- {}&quot;, name)
}

fn main() {
    let name = env::args().nth(1).unwrap();
    println!(&quot;{}&quot;, greeting(name));
}
</code></pre></pre>
<p>This code:</p>
<ol>
<li>defines the <code>greeting</code> function which takes a name and returns a greeting message</li>
<li>defines the <code>main</code> function which reads the first argument, passes it to the <code>greeting</code> function, and prints the returned result</li>
</ol>
<p>Let's now compile and run our example:</p>
<pre><code class="language-bash">~/hello-world $ cargo +nightly run MyName
   Compiling hello-world v0.1.0 (/root/hello-world)
    Finished dev [unoptimized + debuginfo] target(s) in 0.70s
     Running `target/debug/hello-world MyName`
Hello, world! -- MyName
</code></pre>
<hr />
<p><strong>WARNING!</strong> If you see the following error, you should install <a href="https://gcc.gnu.org/install/">gcc</a> and try <code>cargo +nightly run</code> again:</p>
<pre><code class="language-bash">Compiling hello-world v0.1.0 (/root/hello-world)
error: linker cc not found
  |
  = note: No such file or directory (os error 2)

error: aborting due to previous error
error: Could not compile hello-world.
</code></pre>
<hr />
<p>Now that we have a working Hello World application, it's time to adapt it for Fluence.</p>
<a class="header" href="#creating-a-hello-world-backend-for-fluence" id="creating-a-hello-world-backend-for-fluence"><h2>Creating a Hello World backend for Fluence</h2></a>
<p>For a backend to be compatible with the Fluence network, it should follow few conventions to let Fluence nodes run your code correctly. To reduce the amount of boilerplate code, we have developed the Rust SDK. Let's see how to use it.</p>
<a class="header" href="#adding-fluence-as-a-dependency" id="adding-fluence-as-a-dependency"><h3>Adding Fluence as a dependency</h3></a>
<p>First you need to add the Fluence Rust SDK to as a dependency.<br />
Let's take a look at <code>Cargo.toml</code>:</p>
<pre><code class="language-bash">~/hello-world $ cat Cargo.toml
</code></pre>
<p>It should look like this:</p>
<pre><code class="language-toml">[package]
name = &quot;hello-world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;root&quot;]
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<p>Now, open <code>Cargo.toml</code> in the editor, and add <code>fluence</code> to <code>dependencies</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;hello-world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;root&quot;]
edition = &quot;2018&quot;

[dependencies]
fluence = {version = &quot;0.0.11&quot;}
</code></pre>
<a class="header" href="#implementing-the-backend-logic" id="implementing-the-backend-logic"><h3>Implementing the backend logic</h3></a>
<p>Create and open <code>~/hello-world/src/lib.rs</code> in the editor and paste the following code there:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use fluence::sdk::*;

#[invocation_handler]
fn greeting(name: String) -&gt; String {
    format!(&quot;Hello, world! From user {}&quot;, name)
}
#}</code></pre></pre>
<p>This code imports the Fluence SDK, and marks the <code>greeting</code> function with the <code>#[invocation_handler]</code> macro.</p>
<p>The function marked with the <code>#[invocation_handler]</code> macro is called a <em>gateway function</em>. It is essentially the entry point to your application: all client transactions will be passed to this function, and once it returns a result, clients can read this result.</p>
<p>Gateway functions are allowed to take and return only <code>String</code> or <code>Vec&lt;u8&gt;</code> values – check out the <a href="quickstart/../backend/rust/sdk.html">SDK overview</a> for more information.</p>
<a class="header" href="#making-it-a-library" id="making-it-a-library"><h3>Making it a library</h3></a>
<p>For the gateway function to be correctly exported and thus available for Fluence, the backend should be compiled to WebAssembly as a library.</p>
<p>To make the backend a library, open <code>Cargo.toml</code> in the editor, and add the <code>[lib]</code>section:</p>
<pre><code class="language-toml">[package]
name = &quot;hello-world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;root&quot;]
edition = &quot;2018&quot;

[lib]
name = &quot;hello_world&quot;
path = &quot;src/lib.rs&quot;
crate-type = [&quot;cdylib&quot;]

[dependencies]
fluence = { version = &quot;0.0.11&quot;}
</code></pre>
<a class="header" href="#compiling-to-webassembly" id="compiling-to-webassembly"><h3>Compiling to WebAssembly</h3></a>
<p>To build the <code>.wasm</code> file, run this from the application directory:<br />
<small>(note: downloading and compiling dependencies might take a few minutes)</small></p>
<pre><code class="language-bash">~/hello-world $ cargo +nightly build --lib --target wasm32-unknown-unknown --release
    Updating crates.io index
    ...
    Finished release [optimized] target(s) in 1m 16s
</code></pre>
<p>If everything goes well, you should get the <code>.wasm</code> file deep in the target directory.<br />
Let's check it:</p>
<pre><code class="language-bash">~/hello-world $ ls -lh target/wasm32-unknown-unknown/release/hello_world.wasm
-rwxr-xr-x  2 user  user  1.4M Feb 11 11:59 target/wasm32-unknown-unknown/release/hello_world.wasm
</code></pre>
<a class="header" href="#developing-the-backend-app-1" id="developing-the-backend-app-1"><h1>Developing the backend app</h1></a>
<p>Fluence runs WebAssembly programs, so it is possible to build a Fluence backend in any language that targets WebAssembly. In this guide we will use Rust as a language of choice.</p>
<p>First you will build a hello world Rust app, adapt it to Fluence, and then compile it to WebAssembly.</p>
<a class="header" href="#setting-up-rust-1" id="setting-up-rust-1"><h2>Setting up Rust</h2></a>
<p>Let's get some Rust!</p>
<p>Install the Rust compiler:</p>
<pre><code class="language-bash"># installs the Rust compiler and supplementary tools to `~/.cargo/bin`
~ $ curl https://sh.rustup.rs -sSf | sh -s -- -y
info: downloading installer
...
Rust is installed now. Great!
To configure your current shell run source $HOME/.cargo/env
</code></pre>
<p>Let's listen to the installer and configure your current shell:<br />
<small>(new shell environments should pick up the right configuration automatically)</small></p>
<pre><code class="language-bash">~ $ source $HOME/.cargo/env
&lt;no output&gt;
</code></pre>
<p>After that, we need to install the nighly Rust toolchain:<br />
<small>(Fluence Rust SDK requires the nightly toolchain due to certain memory operations)</small></p>
<pre><code class="language-bash">~ $ rustup toolchain install nightly
info: syncing channel updates ...
...
  nightly-&lt;arch&gt; installed - rustc 1.34.0-nightly (57d7cfc3c 2019-02-11)
</code></pre>
<p>Let's check that the nightly toolchain was installed successfully:</p>
<pre><code class="language-bash">~ $ rustup toolchain list | grep nightly
# the output should contain the nighly toolchain
...
nightly-&lt;arch&gt;
</code></pre>
<p>To compile Rust to WebAssembly, we also need to add the <code>wasm32</code> compilation target:</p>
<pre><code class="language-bash"># install target for WebAssembly
~ $ rustup target add wasm32-unknown-unknown --toolchain nightly
info: downloading component 'rust-std' for 'wasm32-unknown-unknown'
info: installing component 'rust-std' for 'wasm32-unknown-unknown'
</code></pre>
<p>Finally, let's check that everything was set up correctly and compile a sample Rust code:</p>
<pre><code class="language-bash"># create a simple program that always returns 1
~ $ echo &quot;fn main(){1;}&quot; &gt; test.rs

# compile it to WebAssembly using rustc from the nightly toolchain
~ $ rustup run nightly rustc --target=wasm32-unknown-unknown test.rs
&lt;no output&gt;

# check that the test.wasm output file was created
~ $ ls -lh test.wasm
-rwxr-xr-x  1 user  user   1.4M Feb 11 11:59 test.wasm
</code></pre>
<p>If everything looks similar, then it's time to create a Rust hello-world project!</p>
<a class="header" href="#creating-an-empty-rust-package-1" id="creating-an-empty-rust-package-1"><h2>Creating an empty Rust package</h2></a>
<p>Let's create a new empty Rust package:</p>
<pre><code class="language-bash"># create empty Rust package
~ $ cargo +nightly new hello-world --edition 2018
Created binary (application) `hello-world` package

# go to the package directory
~ $ cd hello-world
~/hello-world $
</code></pre>
<p>More info on creating a new Rust project can be found in the Rust <a href="https://doc.rust-lang.org/cargo/guide/creating-a-new-project.html">Cargo book</a>.</p>
<a class="header" href="#optional-creating-a-hello-world-rust-application-1" id="optional-creating-a-hello-world-rust-application-1"><h2>[Optional] Creating a Hello World Rust application</h2></a>
<p>If you are already familiar with Rust, feel free to skip this section.</p>
<p>Let's write some code: our backend should receive a user name from the program input, and then print a greeting.</p>
<p>Take a look at <code>src/main.rs</code>:</p>
<pre><code class="language-bash">~/hello-world $ cat src/main.rs
</code></pre>
<p>You will see the following code, which should be there by default and almost does what we need:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Open <code>src/main.rs</code> in any editor, delete all existing code, and paste the following:</p>
<pre><pre class="playpen"><code class="language-rust">use std::env;

fn greeting(name: String) -&gt; String {
    format!(&quot;Hello, world! -- {}&quot;, name)
}

fn main() {
    let name = env::args().nth(1).unwrap();
    println!(&quot;{}&quot;, greeting(name));
}
</code></pre></pre>
<p>This code:</p>
<ol>
<li>defines the <code>greeting</code> function which takes a name and returns a greeting message</li>
<li>defines the <code>main</code> function which reads the first argument, passes it to the <code>greeting</code> function, and prints the returned result</li>
</ol>
<p>Let's now compile and run our example:</p>
<pre><code class="language-bash">~/hello-world $ cargo +nightly run MyName
   Compiling hello-world v0.1.0 (/root/hello-world)
    Finished dev [unoptimized + debuginfo] target(s) in 0.70s
     Running `target/debug/hello-world MyName`
Hello, world! -- MyName
</code></pre>
<hr />
<p><strong>WARNING!</strong> If you see the following error, you should install <a href="https://gcc.gnu.org/install/">gcc</a> and try <code>cargo +nightly run</code> again:</p>
<pre><code class="language-bash">Compiling hello-world v0.1.0 (/root/hello-world)
error: linker cc not found
  |
  = note: No such file or directory (os error 2)

error: aborting due to previous error
error: Could not compile hello-world.
</code></pre>
<hr />
<p>Now that we have a working Hello World application, it's time to adapt it for Fluence.</p>
<a class="header" href="#creating-a-hello-world-backend-for-fluence-1" id="creating-a-hello-world-backend-for-fluence-1"><h2>Creating a Hello World backend for Fluence</h2></a>
<p>For a backend to be compatible with the Fluence network, it should follow few conventions to let Fluence nodes run your code correctly. To reduce the amount of boilerplate code, we have developed the Rust SDK. Let's see how to use it.</p>
<a class="header" href="#adding-fluence-as-a-dependency-1" id="adding-fluence-as-a-dependency-1"><h3>Adding Fluence as a dependency</h3></a>
<p>First you need to add the Fluence Rust SDK to as a dependency.<br />
Let's take a look at <code>Cargo.toml</code>:</p>
<pre><code class="language-bash">~/hello-world $ cat Cargo.toml
</code></pre>
<p>It should look like this:</p>
<pre><code class="language-toml">[package]
name = &quot;hello-world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;root&quot;]
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<p>Now, open <code>Cargo.toml</code> in the editor, and add <code>fluence</code> to <code>dependencies</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;hello-world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;root&quot;]
edition = &quot;2018&quot;

[dependencies]
fluence = {version = &quot;0.0.11&quot;}
</code></pre>
<a class="header" href="#implementing-the-backend-logic-1" id="implementing-the-backend-logic-1"><h3>Implementing the backend logic</h3></a>
<p>Create and open <code>~/hello-world/src/lib.rs</code> in the editor and paste the following code there:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use fluence::sdk::*;

#[invocation_handler]
fn greeting(name: String) -&gt; String {
    format!(&quot;Hello, world! From user {}&quot;, name)
}
#}</code></pre></pre>
<p>This code imports the Fluence SDK, and marks the <code>greeting</code> function with the <code>#[invocation_handler]</code> macro.</p>
<p>The function marked with the <code>#[invocation_handler]</code> macro is called a <em>gateway function</em>. It is essentially the entry point to your application: all client transactions will be passed to this function, and once it returns a result, clients can read this result.</p>
<p>Gateway functions are allowed to take and return only <code>String</code> or <code>Vec&lt;u8&gt;</code> values – check out the <a href="quickstart/../backend/rust/sdk.html">SDK overview</a> for more information.</p>
<a class="header" href="#making-it-a-library-1" id="making-it-a-library-1"><h3>Making it a library</h3></a>
<p>For the gateway function to be correctly exported and thus available for Fluence, the backend should be compiled to WebAssembly as a library.</p>
<p>To make the backend a library, open <code>Cargo.toml</code> in the editor, and add the <code>[lib]</code>section:</p>
<pre><code class="language-toml">[package]
name = &quot;hello-world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;root&quot;]
edition = &quot;2018&quot;

[lib]
name = &quot;hello_world&quot;
path = &quot;src/lib.rs&quot;
crate-type = [&quot;cdylib&quot;]

[dependencies]
fluence = { version = &quot;0.0.11&quot;}
</code></pre>
<a class="header" href="#compiling-to-webassembly-1" id="compiling-to-webassembly-1"><h3>Compiling to WebAssembly</h3></a>
<p>To build the <code>.wasm</code> file, run this from the application directory:<br />
<small>(note: downloading and compiling dependencies might take a few minutes)</small></p>
<pre><code class="language-bash">~/hello-world $ cargo +nightly build --lib --target wasm32-unknown-unknown --release
    Updating crates.io index
    ...
    Finished release [optimized] target(s) in 1m 16s
</code></pre>
<p>If everything goes well, you should get the <code>.wasm</code> file deep in the target directory.<br />
Let's check it:</p>
<pre><code class="language-bash">~/hello-world $ ls -lh target/wasm32-unknown-unknown/release/hello_world.wasm
-rwxr-xr-x  2 user  user  1.4M Feb 11 11:59 target/wasm32-unknown-unknown/release/hello_world.wasm
</code></pre>
<a class="header" href="#developing-the-backend-app-on-assemblyscript" id="developing-the-backend-app-on-assemblyscript"><h1>Developing the backend app on AssemblyScript</h1></a>
<p>Let's build Hello World app for Fluence.</p>
<a class="header" href="#requirements" id="requirements"><h2>Requirements</h2></a>
<ul>
<li>installed <code>npm</code></li>
</ul>
<a class="header" href="#initialize-project" id="initialize-project"><h2>Initialize project</h2></a>
<ol>
<li>Create a new directory for a project</li>
<li>Run <code>npx fluencelabs/fl-init</code> from directory.</li>
<li>Wait one minute. Enter 'y' when asked.</li>
<li>This script will initialize project, that we can already compile to WebAssembly and deploy into Fluence system.</li>
</ol>
<a class="header" href="#creating-a-hello-world-backend-for-fluence-2" id="creating-a-hello-world-backend-for-fluence-2"><h2>Creating a Hello World backend for Fluence</h2></a>
<p>All we need for now is to change <code>handle</code> function in <code>main.ts</code> file:</p>
<pre><code class="language-js">// main handler for an application
export function handler(request: string): string {
  return &quot;&quot;;
}
</code></pre>
<p>Change empty string with <code>return &quot;Hello, &quot; + request + &quot;!&quot;</code> and that's it, the app is ready.</p>
<a class="header" href="#build-wasm-file" id="build-wasm-file"><h2>Build <code>wasm</code> file</h2></a>
<ol>
<li>Run <code>npm run flbuild</code> in the project directory.</li>
<li>File <code>build/optimized.wasm</code> will be created.</li>
<li>You can publish this file like in <a href="quickstart/publish.html">Publishing the backend app</a> tutorial.</li>
</ol>
<a class="header" href="#advanced" id="advanced"><h2>Advanced</h2></a>
<p>For deeper understanding let's open <code>assembly/index.ts</code> file. We can see functions, that are gateways from outer VM to written code:</p>
<pre><code class="language-js">...
// VM wrapper will put requests to memory through this function
export function allocate(size: usize) :i32 {
  return memory.allocate(size);
}

// VM wrapper will deallocate response from memory after handling it
export function deallocate(ptr: i32, size: usize): void {
  memory.free(ptr);
  // use 'memory.reset()' for reset memory after every request
}

// VM wrapper calls this function with a pointer on request in memory.
// Returns pointer on a response.
export function invoke(ptr: i32, size: i32): i32 {
    // this function will parse a request as a string and return result string as a pointer in memory
    // you can look on other functions in 'assemblyscript-sdk' library to handle own types of requests and responses
    return loggedStringHandler(ptr, size, handler, log);
}
</code></pre>
<p>Function <code>loggedStringHandler</code> in <code>invoke</code> use <code>handler</code> to handle incoming messages and returning response. There are some other methods for interacting with requests and responses in different formats. You can look at them here <a href="https://github.com/fluencelabs/assemblyscript-sdk/blob/master/assembly/index.ts">AssemblyScript SDK</a></p>
<a class="header" href="#examples" id="examples"><h2>Examples</h2></a>
<p><a href="https://github.com/fluencelabs/tutorials/tree/master/dice-game/backend-as">Dice game</a>
<a href="https://github.com/fluencelabs/tutorials/tree/master/dice-game/backend-db-as">Multimodule dice game with connected DB written on Rust</a></p>
<a class="header" href="#assemblyscript" id="assemblyscript"><h2>AssemblyScript</h2></a>
<p><a href="https://github.com/AssemblyScript/assemblyscript">AssemblyScript introduction</a></p>
<a class="header" href="#limitations-of-assemblyscript" id="limitations-of-assemblyscript"><h2>Limitations of AssemblyScript</h2></a>
<p>It is important to note that AssemblyScript is NOT TypeScript. There are several important features that are missing notably:</p>
<ul>
<li>interfaces</li>
<li>use of untyped variables or the any type</li>
<li>JSON.parse/JSON.stringify</li>
<li>virtual methods (the method of the compile time type will always be called)</li>
</ul>
<a class="header" href="#publishing-the-backend-app" id="publishing-the-backend-app"><h1>Publishing the backend app</h1></a>
<p>In the Fluence network, applications are deployed by uploading WebAssembly code to IPFS, and publishing hashes of the uploaded code to the Fluence smart contract.</p>
<p>It is also possible to specify the desired cluster size, which sets the required number of real-time workers in the cluster hosting the application. Note that the application might wait in the queue until there are enough free workers to form a cluster of the desired size.</p>
<a class="header" href="#connecting-to-ipfs-and-ethereum-rinkeby-nodes" id="connecting-to-ipfs-and-ethereum-rinkeby-nodes"><h2>Connecting to IPFS and Ethereum Rinkeby nodes</h2></a>
<p>To make sure we're on the same page:</p>
<ul>
<li>IPFS is a decentralized file storage</li>
<li>Ethereum Rinkeby is one of Ethereum testnets, which works with toy money</li>
<li>Fluence smart contract is what rules the Fluence network</li>
</ul>
<p>To upload the application code to IPFS, you need to have access to one of IPFS nodes. The same with Ethereum: you need access to any Ethereum node running Rinkeby testnet.</p>
<p>For your convenience and to make this guide simpler, we use Ethereum and IPFS nodes set up by Fluence Labs, but you can use any other nodes if you wish.</p>
<p><strong>WARNING! This is not a secure way to connect to Ethereum or IPFS.</strong><br />
It should not be used in production or in a security-sensitive context.</p>
<a class="header" href="#registering-an-ethereum-rinkeby-account" id="registering-an-ethereum-rinkeby-account"><h2>Registering an Ethereum Rinkeby account</h2></a>
<a class="header" href="#via-myetherwalletcom" id="via-myetherwalletcom"><h3>Via myetherwallet.com</h3></a>
<p>Go to <a href="https://vintage.myetherwallet.com/">MyEtherWallet.com</a>, select any Rinkeby in the upper right dropdown, enter any password, and download the Keystore file. You will find your account address in the last part of the Keystore file name, for example:</p>
<pre>
UTC--2019-03-03T14-48-59.325Z--<b>e1f9c157b45838ca83cb51b7bdcc6c7a3e56650f</b>
</pre>
<a class="header" href="#top-up-your-account-with-funds" id="top-up-your-account-with-funds"><h3>Top up your account with funds</h3></a>
<p>There are two main Rinkeby faucets.</p>
<p><a href="https://faucet.rinkeby.io/">This one</a> gives you up to 18 Ether, but it requires you to post an Ethereum address to a social network.</p>
<p><a href="http://rinkeby-faucet.com/">Another one</a> gives you ETH right away, but just 0.001 Ether, which isn't enough for the publishing, so you may try to top up several times.</p>
<a class="header" href="#installing-the-fluence-cli" id="installing-the-fluence-cli"><h2>Installing the Fluence CLI</h2></a>
<p>It is hard to send publication transactions manually, so we provide the Fluence CLI.<br />
You can download the CLI from the <a href="https://github.com/fluencelabs/fluence/releases/">releases</a> page, or fetch it in the terminal:</p>
<p><strong>Linux</strong></p>
<pre><code class="language-bash">curl -L https://github.com/fluencelabs/fluence/releases/download/v0.1.6/fluence-cli-0.1.6-linux-x64 -o fluence
</code></pre>
<p><strong>macOS</strong></p>
<pre><code class="language-bash">curl -L https://github.com/fluencelabs/fluence/releases/download/v0.1.6/fluence-cli-0.1.6-mac-x64 -o fluence

</code></pre>
<p>Don't forget to add permissions to run it:</p>
<pre><code class="language-bash">chmod +x ./fluence

# check that the CLI is working
./fluence --version
Fluence CLI 0.1.6
</code></pre>
<a class="header" href="#publishing-the-application-with-the-fluence-cli" id="publishing-the-application-with-the-fluence-cli"><h2>Publishing the application with the Fluence CLI</h2></a>
<p>As we have already mentioned, you need to have access to the Ethereum Rinkeby and IPFS networks. You can either use Ethereum and IPFS nodes set up by Fluence Labs, or specify other nodes by providing their URIs using <code>--eth_url</code> and <code>--storage_url</code> options.</p>
<p>You also need a Rinkeby account with some money on it (you can <a href="https://faucet.rinkeby.io/">get Ethers from faucet</a>) and its private key, which can either be a hex string or a <a href="quickstart/../cli.html#keystore-json-file">Keystore file</a>.</p>
<p>To interact with the Fluence CLI, we will set it up first:</p>
<pre><code class="language-bash">./fluence setup
</code></pre>
<p>This command will ask you to enter the Fluence contract address, IPFS and Ethereum node addresses, and, finally, your account credentials. It will create the config file which will be used by the CLI tool in the future.</p>
<p>By default, IPFS and Ethereum nodes controlled by Fluence Labs will be used. Note that you need to provide either the secret key <strong>or</strong> the Keystore file path + password to be able to send transactions to Ethereum.</p>
<p>Having all that, now you are ready to publish your application:</p>
<pre><code class="language-bash">./fluence publish \
            --code_path        ~/hello-world/target/wasm32-unknown-unknown/release/hello_world.wasm \
            --gas_price        10 \
            --cluster_size     4 \
            --wait_syncing \
            --wait
</code></pre>
<p>Once the command completes, you should see an output similar to the following:</p>
<pre><code class="language-bash">[1/3]   Application code uploaded. ---&gt; [00:00:00]
IPFS hash: 0xf5c604478031e9a658551220da3af1f086965b257e7375bbb005e0458c805874
[2/3]   Transaction publishing app was sent. ---&gt; [00:00:03]
  tx hash: 0x5552ee8f136bce0b020950676d84af00e4016490b8ee8b1c51780546ad6016b7
[3/3]   Transaction was included. ---&gt; [00:02:38]
App deployed.
  app id: 2
  tx hash: 0x5552ee8f136bce0b020950676d84af00e4016490b8ee8b1c51780546ad6016b7
</code></pre>
<a class="header" href="#verifying-the-application-status" id="verifying-the-application-status"><h2>Verifying the application status</h2></a>
<p>To check the state of your application – for example, which nodes it was deployed to, go to the <a href="http://dash.fluence.network">dashboard</a>, and find your app in the apps list:</p>
<div style="text-align:center">
<kbd>
<img src="../images/apps.png" width="544px"/>
</kbd>
<br><br><br>
</div>
<p>Click on your app, you will see it's status:</p>
<div style="text-align:center">
<kbd>
<img src="../images/app_status.png" width="544px"/>
</kbd>
<br><br><br>
</div>
<p>Press on the <code>Check cluster</code> button, and after a while green boxes with a number on it will appear. That is the height of your app's Tendermint blockchain.</p>
<p>For a healthy cluster, it should be bigger than 1, that means that application was started successfully, and ready to work!</p>
<a class="header" href="#developing-the-web-app" id="developing-the-web-app"><h1>Developing the web app</h1></a>
<p>For this part, you need installed <code>npm</code>. Please refer to <a href="https://www.npmjs.com/get-npm">npm docs</a> for installation instructions.</p>
<a class="header" href="#preparing-web-application" id="preparing-web-application"><h2>Preparing web application</h2></a>
<p>Let's clone a simple web app template:</p>
<pre><code class="language-bash">~ $ git clone https://github.com/fluencelabs/frontend-template
~ $ cd frontend-template
~/frontend-template $ 
</code></pre>
<p>Inside you should find:</p>
<ul>
<li><code>package.json</code> which adds required dependencies</li>
<li><code>webpack.config.js</code> which is needed for the webpack to work</li>
<li><code>index.js</code> which demonstrates how to interact with the real-time cluster</li>
</ul>
<p>The template web application uses the Fluence frontend SDK. This SDK allows to locate the real-time cluster with the help of the Fluence smart contract, and then send transactions to this cluster.</p>
<p>Let's take a look at <code>index.js</code>:</p>
<pre><code class="language-javascript">
// the address of the Fluence smart contract on Ethereum
let contractAddress = &quot;0xeFF91455de6D4CF57C141bD8bF819E5f873c1A01&quot;;

// the address of the Ethereum node
// MetaMask is used to send transactions if this address is set to `undefined`, 
let ethUrl = &quot;http://data.fluence.one:8545/&quot;;

// the backend appId as seen in the Fluence smart contract
let appId = &quot;6&quot;;

...

// create a session between the frontend client and the backend application
// the session is used to send transactions to the real-time cluster
fluence.connect(contractAddress, appId, ethUrl).then((s) =&gt; {
  console.log(&quot;Session created&quot;);
  window.session = s;
  helloBtn.disabled = false;
});

...

// set a callback on the button click
helloBtn.addEventListener(&quot;click&quot;, send)

// send a transaction with the name to the real-time cluster and display the response
function send() {
  const username = usernameInput.value.trim();
  let result = session.invoke(username);
  getResultString(result).then(function (str) {
    greetingLbl.innerHTML = str;
  });
}
</code></pre>
<a class="header" href="#running-the-web-application" id="running-the-web-application"><h2>Running the web application</h2></a>
<p>Make sure that you have changed the <code>appId</code> variable to the identifier of the deployed backend!</p>
<p>To install dependencies, and compile and run your web application, run:</p>
<pre><code class="language-bash">~/frontend-template $ npm install
~/frontend-template $ npm run start
&gt; frontend-template@1.0.0 start /private/tmp/frontend-template
&gt; webpack-dev-server

ℹ ｢wds｣: Project is running at http://localhost:8080/
...
</code></pre>
<p>Now you can open <a href="http://localhost:8080/">http://localhost:8080/</a> in your browser. You should see an input text element and a disabled button, which should become enabled once the session with the backend is initialized.</p>
<div style="text-align:center">
<kbd>
<img src="../images/helloworld.png" width="610px"/>
</kbd>
<br><br>
</div>
<p>You can also open the developer console, and check out the Fluence SDK logs:</p>
<pre><code>...
Connecting web3 to http://207.154.232.92:8545
...
Session created
</code></pre>
<p>You can also interact with the backend application from the developer console:</p>
<pre><code class="language-javascript">let result = session.invoke(&quot;MyName&quot;);
&lt;undefined&gt;
logResultAsString(result);
&lt;undefined&gt;
Hello, world! -- MyName
</code></pre>
<a class="header" href="#website-with-fluence-backend-and-static-resources-on-ipfs" id="website-with-fluence-backend-and-static-resources-on-ipfs"><h1>Website with Fluence backend and static resources on IPFS</h1></a>
<a class="header" href="#motivation-1" id="motivation-1"><h2>Motivation</h2></a>
<p>Fluence nodes are stateful but it is wasteful to store website (or something else) static resources on them. We can use decentralized storage like IPFS to store static resources and save the decentralized state of the whole system.</p>
<a class="header" href="#requirements-1" id="requirements-1"><h2>Requirements</h2></a>
<ul>
<li><a href="https://docs.ipfs.io/introduction/install/">IPFS CLI</a> to upload resources</li>
</ul>
<a class="header" href="#how-to" id="how-to"><h2>How To</h2></a>
<p>First of all, we need already written frontend interacting with Fluence nodes.</p>
<p>And then let's upload directory with built frontend code:</p>
<pre><code>IPFS_ADDR=$(host data.fluence.one | awk '/has address/ { print $4 }')
ipfs --api /ip4/$IPFS_ADDR/tcp/5001 add -r path/to/built/frontend
</code></pre>
<p><code>IPFS_ADDR</code> - is a data.fluence.one ip address</p>
<p>This command will return a hash of directory. We can check if the directory is uploaded by opening a link with this hash: <code>http://data.fluence.one:8080/ipfs/&lt;IpfsHash&gt;</code></p>
<p>That's it! Now your frontend code is available with this link: <code>http://data.fluence.one:8080/ipfs/&lt;IpfsHash&gt;/index.html</code></p>
<p>Note, that your entrypoint is not <code>index.html</code>, change the link to right one. </p>
<a class="header" href="#recap" id="recap"><h1>Recap</h1></a>
<p>Thanks for finishing the quickstart guide!</p>
<p>A short recap of what you have developed and learned:</p>
<ul>
<li>How to set up Rust and Node.js environments from scratch.</li>
<li>How to interact with Ethereum and IPFS through the Fluence CLI.</li>
<li>How to spin up a decentralized backend running in the Fluence network, and build frontend applications interacting with this backend.</li>
</ul>
<p>Hope this was fun!</p>
<p>Join our <a href="https://discordapp.com/invite/AjfbDKQ">Discord</a> if you have any feedback, questions, or ideas what could be built with Fluence :)</p>
<a class="header" href="#backend-guide" id="backend-guide"><h1>Backend guide</h1></a>
<p>Backend applications deployed to Fluence nodes are usually composed of two logical parts. The first part is the domain logic code produced by a developer. The second part is the Fluence SDK, which is responsible for accepting transactions, finding the right domain function to call, invoking this function and returning results back to the state machine.</p>
<div style="text-align:center">
<kbd>
<img src="../images/sdk_overview.png" width="711px"/>
</kbd>
<br><br>
</div>
<p>It is not necessary for a developer to use Fluence SDK – it merely exists to make development more convenient. However, there are certain rules which the code running within WebAssembly VM is expected to follow, so if you want to build unpadded applications or implement your own SDK please consult the <a href="backend/./internals.html">following document</a>.</p>
<p>If you would like to learn how to build backend applications using the Fluence SDK, please visit the <a href="backend/./sdk_overview.html">SDK overview</a>.</p>
<a class="header" href="#backend-rust-sdk-overview" id="backend-rust-sdk-overview"><h1>Backend Rust SDK overview</h1></a>
<p>Fluence backend SDK consists of two crates: <code>main</code> and <code>macro</code>. The <code>main</code> crate is used for all memory relative operations and logging, while the <code>macro</code> crate contains the macro to simplify entry point functions. These crates can be used separately but the preferred way is to use the global <code>fluence</code> crate which combines all the others.</p>
<p>In Rust 2018 this can be done by adding <a href="https://crates.io/crates/fluence">Fluence SDK</a> as a dependency, and then adding <code>use fluence::sdk::*</code> to Rust sources.</p>
<a class="header" href="#rust-2015" id="rust-2015"><h2>Rust 2015</h2></a>
<p>To use Fluence SDK with Rust 2015 import it like this:</p>
<pre><code class="language-Rust">#![feature(custom_attribute)]
extern crate fluence;

use fluence::sdk::*;
</code></pre>
<p>Example Rust 2015 application can be found <a href="https://github.com/fluencelabs/tutorials/tree/master/hello-world/app-logger-rust-2015">here</a>.</p>
<a class="header" href="#entry-point-function" id="entry-point-function"><h2>Entry point function</h2></a>
<p>Each WebAssembly backend application deployed to the Fluence network is expected to provide a single entry point function named <code>invoke</code>. The easiest way to implement this function is to use the <code>invocation_handler</code> macro provided by the Fluence SDK:</p>
<pre><code class="language-Rust">use fluence::sdk::*;

#[invocation_handler]
fn greeting(name: String) -&gt; String {
    format!(&quot;Hello, world! -- {}&quot;, name)
}
</code></pre>
<p>If anything goes wrong, <a href="https://github.com/dtolnay/cargo-expand">cargo expand</a> can be used for troubleshooting and macros debugging.  Keep in mind that the function which the macro is attached to should:</p>
<ul>
<li>not have more than one input argument and always return a value</li>
<li>not be unsafe, const, generic, or have custom abi linkage or variadic params</li>
<li>have the input argument type (if present) and return type to be either <code>String</code> or <code>Vec&lt;u8&gt;</code></li>
<li>not use the <code>invoke</code> name, which is reserved by the Fluence SDK</li>
</ul>
<p>The <code>invocation_handler</code> macro additionally allows to specify the initialization function:</p>
<pre><code class="language-Rust">use fluence::sdk::*;

fn init() {
    // will be called just before the first `greeting()` function invocation
}

#[invocation_handler(init_fn = init)]
fn greeting(name: String) -&gt; String {
    format!(&quot;Hello, world! -- {}&quot;, name)
}
</code></pre>
<p>The initialization function will be called only once and before any other code when the first transaction arrives. Therefore, it is a great place to put the code preparing the backend application.</p>
<a class="header" href="#logging" id="logging"><h2>Logging</h2></a>
<p><strong>TBD</strong></p>
<!-- ## App runner
<p>Sometimes it needs not only a debug output but a possibility to run a compiled Wasm <code>app</code> with some different inputs. It can be done by using so-called runner written on Scala (because it uses a <code>WasmVm</code> implementation that also written on Scala).</p>
<p>Let's a dig a little bit into the <code>hello-world2</code> <a href="(https://github.com/fluencelabs/fluence/tree/master/vm/examples/hello-world2/runner)">runner</a>. It receives a path to a Wasm binary as the first CLI argument, then creates a <code>vm</code> object that extends <code>WasmVm</code> trait. During this creation, Wasm code is compiled by Asmble to JVM and loaded into VM. This trait has two public methods: <code>invoke</code> that manages requests to <code>app</code> and <code>getVmState</code> that computes a hash of significant inner state. In the following code snippet</p>
<pre><code class="language-Scala">      inputFile &lt;- EitherT(getWasmFilePath(args).attempt)
        .leftMap(e =&gt; InternalVmError(e.getMessage, Some(e)))
        
      vm ← WasmVm[IO](NonEmptyList.one(inputFile), &quot;fluence.vm.debugger&quot;)
      
      initState ← vm.getVmState[IO]

      result1 ← vm.invoke[IO](None, &quot;John&quot;.getBytes())
</code></pre>
<p><code>inputFile</code> points to a supplied path to wasm file. Then WasmVm instance is created with the path to input file and <code>fluence.vm.debugger</code> config. This config (for the <code>hello-world2</code> <code>app</code> it can be found <a href="https://github.com/fluencelabs/fluence/blob/master/vm/examples/hello-world2/runner/src/main/resources/reference.conf">here</a>) contains some useful settings that control some inner VM creation process a little bit:</p>
<ul>
<li>
<p><code>defaultMaxMemPages</code> - the maximum number of memory pages when a module doesn't specify it, each Wasm page according to the specification contains 65536 bytes (64 by default, 65536*64 = 4MB)</p>
</li>
<li>
<p><code>loggerRegister</code> - if &gt; 0, registers the logger Wasm module as <code>logger</code> with specified number of memory pages, that allows to logs to stdout (0  by default in mainnet and 2 by default for runners)</p>
</li>
<li>
<p><code>allocateFunctionName</code> - the name of function that should be called for memory allocation (<code>allocate</code> by default)</p>
</li>
<li>
<p><code>deallocateFunctionName</code> - the name of function that should be called for deallocation of previously allocated memory by <code>allocateFunction</code> (<code>deallocate</code> by default)</p>
</li>
<li>
<p><code>invokeFunctionName</code> - the name of the main module handler function (<code>invoke</code> by default)</p>
</li>
</ul>
<p>Then the hash of internal state is computed by <code>vm.getVmState</code> and <code>invoke</code> from <code>app</code> is called by <code>vm.invoke</code>.</p>
<a class="header" href="#wasm-logger" id="wasm-logger"><h2>Wasm logger</h2></a>
<p>To debug backend applications, the SDK provides
There are a few debugging capabilities for Wasm program. The Fluence network provides a possibility to so-called print-debugging. It can be included by specifying the <code>wasm_logger</code> feature of the sdk.</p>
<p>The logger is implemented as a logging facade for crate <a href="https://github.com/rust-lang-nursery/log">log</a>. It means that all <code>log</code> crate possibilities can be used as usual. Let's review it by the example of <a href="https://github.com/fluencelabs/fluence/tree/master/vm/examples/hello-world2/app-2018">hello-world2</a> application with simple logging:</p>
<pre><code class="language-Rust">use fluence::sdk::*;
use log::info;

fn init() {
    logger::WasmLogger::init_with_level(log::Level::Info).is_ok()
}

#[invocation_handler(init_fn = init)]
fn main(name: String) -&gt; String {
    info!(&quot;{} has been successfully greeted&quot;, name);
    format!(&quot;Hello from Fluence to {}&quot;, name)
}
</code></pre>
<p>The easiest way to initialize the logger is using the <code>init_fn</code> attribute of <code>invocation_handler</code> like in the example above.</p>
<p>Please also note that this <code>logger</code> is designed only for Wasm environment and Fluence <code>WasmVm</code>. Don't use it for other targets and virtual machines. But if it needs to create a project with <code>logger</code> either for Wasm target and other architectures, a conditional compilation can be used:</p>
<pre><code class="language-Rust">fn init() {
    if cfg!(target_arch = &quot;wasm32&quot;) {
        logger::WasmLogger::init_with_level(log::Level::Info).unwrap();
    } else {
        simple_logger::init_with_level(log::Level::Info).unwrap();
    }
}
</code></pre>
<p>Without this trick <code>app</code> that uses the logger can be compiled only for <code>wasm32-unknown-unknown</code> target.</p>
<p>It is also important to note that by default debugging capabilities is disabled in the Fluence network because of verification game process (you can find more information about it in <a href="TODO">our paper</a>). --&gt;</p>
<a class="header" href="#backend-rust-sdk-overview-1" id="backend-rust-sdk-overview-1"><h1>Backend Rust SDK overview</h1></a>
<p>Fluence backend SDK consists of two crates: <code>main</code> and <code>macro</code>. The <code>main</code> crate is used for all memory relative operations and logging, while the <code>macro</code> crate contains the macro to simplify entry point functions. These crates can be used separately but the preferred way is to use the global <code>fluence</code> crate which combines all the others.</p>
<p>In Rust 2018 this can be done by adding <a href="https://crates.io/crates/fluence">Fluence SDK</a> as a dependency, and then adding <code>use fluence::sdk::*</code> to Rust sources.</p>
<a class="header" href="#rust-2015-1" id="rust-2015-1"><h2>Rust 2015</h2></a>
<p>To use Fluence SDK with Rust 2015 import it like this:</p>
<pre><code class="language-Rust">#![feature(custom_attribute)]
extern crate fluence;

use fluence::sdk::*;
</code></pre>
<p>Example Rust 2015 application can be found <a href="https://github.com/fluencelabs/tutorials/tree/master/hello-world/app-logger-rust-2015">here</a>.</p>
<a class="header" href="#entry-point-function-1" id="entry-point-function-1"><h2>Entry point function</h2></a>
<p>Each WebAssembly backend application deployed to the Fluence network is expected to provide a single entry point function named <code>invoke</code>. The easiest way to implement this function is to use the <code>invocation_handler</code> macro provided by the Fluence SDK:</p>
<pre><code class="language-Rust">use fluence::sdk::*;

#[invocation_handler]
fn greeting(name: String) -&gt; String {
    format!(&quot;Hello, world! -- {}&quot;, name)
}
</code></pre>
<p>If anything goes wrong, <a href="https://github.com/dtolnay/cargo-expand">cargo expand</a> can be used for troubleshooting and macros debugging.  Keep in mind that the function which the macro is attached to should:</p>
<ul>
<li>not have more than one input argument and always return a value</li>
<li>not be unsafe, const, generic, or have custom abi linkage or variadic params</li>
<li>have the input argument type (if present) and return type to be either <code>String</code> or <code>Vec&lt;u8&gt;</code></li>
<li>not use the <code>invoke</code> name, which is reserved by the Fluence SDK</li>
</ul>
<p>The <code>invocation_handler</code> macro additionally allows to specify the initialization function:</p>
<pre><code class="language-Rust">use fluence::sdk::*;

fn init() {
    // will be called just before the first `greeting()` function invocation
}

#[invocation_handler(init_fn = init)]
fn greeting(name: String) -&gt; String {
    format!(&quot;Hello, world! -- {}&quot;, name)
}
</code></pre>
<p>The initialization function will be called only once and before any other code when the first transaction arrives. Therefore, it is a great place to put the code preparing the backend application.</p>
<a class="header" href="#logging-1" id="logging-1"><h2>Logging</h2></a>
<p><strong>TBD</strong></p>
<!-- ## App runner
<p>Sometimes it needs not only a debug output but a possibility to run a compiled Wasm <code>app</code> with some different inputs. It can be done by using so-called runner written on Scala (because it uses a <code>WasmVm</code> implementation that also written on Scala).</p>
<p>Let's a dig a little bit into the <code>hello-world2</code> <a href="(https://github.com/fluencelabs/fluence/tree/master/vm/examples/hello-world2/runner)">runner</a>. It receives a path to a Wasm binary as the first CLI argument, then creates a <code>vm</code> object that extends <code>WasmVm</code> trait. During this creation, Wasm code is compiled by Asmble to JVM and loaded into VM. This trait has two public methods: <code>invoke</code> that manages requests to <code>app</code> and <code>getVmState</code> that computes a hash of significant inner state. In the following code snippet</p>
<pre><code class="language-Scala">      inputFile &lt;- EitherT(getWasmFilePath(args).attempt)
        .leftMap(e =&gt; InternalVmError(e.getMessage, Some(e)))
        
      vm ← WasmVm[IO](NonEmptyList.one(inputFile), &quot;fluence.vm.debugger&quot;)
      
      initState ← vm.getVmState[IO]

      result1 ← vm.invoke[IO](None, &quot;John&quot;.getBytes())
</code></pre>
<p><code>inputFile</code> points to a supplied path to wasm file. Then WasmVm instance is created with the path to input file and <code>fluence.vm.debugger</code> config. This config (for the <code>hello-world2</code> <code>app</code> it can be found <a href="https://github.com/fluencelabs/fluence/blob/master/vm/examples/hello-world2/runner/src/main/resources/reference.conf">here</a>) contains some useful settings that control some inner VM creation process a little bit:</p>
<ul>
<li>
<p><code>defaultMaxMemPages</code> - the maximum number of memory pages when a module doesn't specify it, each Wasm page according to the specification contains 65536 bytes (64 by default, 65536*64 = 4MB)</p>
</li>
<li>
<p><code>loggerRegister</code> - if &gt; 0, registers the logger Wasm module as <code>logger</code> with specified number of memory pages, that allows to logs to stdout (0  by default in mainnet and 2 by default for runners)</p>
</li>
<li>
<p><code>allocateFunctionName</code> - the name of function that should be called for memory allocation (<code>allocate</code> by default)</p>
</li>
<li>
<p><code>deallocateFunctionName</code> - the name of function that should be called for deallocation of previously allocated memory by <code>allocateFunction</code> (<code>deallocate</code> by default)</p>
</li>
<li>
<p><code>invokeFunctionName</code> - the name of the main module handler function (<code>invoke</code> by default)</p>
</li>
</ul>
<p>Then the hash of internal state is computed by <code>vm.getVmState</code> and <code>invoke</code> from <code>app</code> is called by <code>vm.invoke</code>.</p>
<a class="header" href="#wasm-logger-1" id="wasm-logger-1"><h2>Wasm logger</h2></a>
<p>To debug backend applications, the SDK provides
There are a few debugging capabilities for Wasm program. The Fluence network provides a possibility to so-called print-debugging. It can be included by specifying the <code>wasm_logger</code> feature of the sdk.</p>
<p>The logger is implemented as a logging facade for crate <a href="https://github.com/rust-lang-nursery/log">log</a>. It means that all <code>log</code> crate possibilities can be used as usual. Let's review it by the example of <a href="https://github.com/fluencelabs/fluence/tree/master/vm/examples/hello-world2/app-2018">hello-world2</a> application with simple logging:</p>
<pre><code class="language-Rust">use fluence::sdk::*;
use log::info;

fn init() {
    logger::WasmLogger::init_with_level(log::Level::Info).is_ok()
}

#[invocation_handler(init_fn = init)]
fn main(name: String) -&gt; String {
    info!(&quot;{} has been successfully greeted&quot;, name);
    format!(&quot;Hello from Fluence to {}&quot;, name)
}
</code></pre>
<p>The easiest way to initialize the logger is using the <code>init_fn</code> attribute of <code>invocation_handler</code> like in the example above.</p>
<p>Please also note that this <code>logger</code> is designed only for Wasm environment and Fluence <code>WasmVm</code>. Don't use it for other targets and virtual machines. But if it needs to create a project with <code>logger</code> either for Wasm target and other architectures, a conditional compilation can be used:</p>
<pre><code class="language-Rust">fn init() {
    if cfg!(target_arch = &quot;wasm32&quot;) {
        logger::WasmLogger::init_with_level(log::Level::Info).unwrap();
    } else {
        simple_logger::init_with_level(log::Level::Info).unwrap();
    }
}
</code></pre>
<p>Without this trick <code>app</code> that uses the logger can be compiled only for <code>wasm32-unknown-unknown</code> target.</p>
<p>It is also important to note that by default debugging capabilities is disabled in the Fluence network because of verification game process (you can find more information about it in <a href="TODO">our paper</a>). --&gt;</p>
<a class="header" href="#best-practices-for-rust-backend-applications" id="best-practices-for-rust-backend-applications"><h1>Best practices for Rust backend applications</h1></a>
<a class="header" href="#request-routing" id="request-routing"><h2>Request routing</h2></a>
<p>Fluence does not provide a sane request routing yet – only one function can be marked as an entry point. This means that each developer has to independently decide on an input argument format, parse this argument in the entry point function, and call other functions based on the passed action selector.</p>
<p>One option would be to use JSON serialization (for example, provided by <a href="https://github.com/serde-rs/serde">serde</a> and <a href="https://github.com/serde-rs/json">serde_json</a> crates) to wrap input data. Once the input is parsed, the code in the entry point function can perform manual routing:</p>
<pre><code class="language-Rust">use fluence::sdk::*;

use serde_json::{json, Value};
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
pub struct Request {
    pub action: String,
    pub player_name: String,
}

#[invocation_handler]
fn handle_request(req: String) -&gt; String {
  let value: Value = serde_json::from_str(req.as_str())?;
  let request: Request = serde_json::from_value(value.clone())?;
  
  match request.action.as_str() {
    &quot;create_game&quot; =&gt; {
      // create a new game
    }
    
    ...
    
    &quot;move&quot; =&gt; {
      // make a player's move
    }
  }
}
</code></pre>
<a class="header" href="#memory-management" id="memory-management"><h2>Memory management</h2></a>
<p>At the current moment, backend applications cannot use more than 4GB of WebAssembly memory. To avoid running out of memory, applications should carefully plan memory usage. For example, an open to the public multi-user game might employ a <a href="https://en.wikipedia.org/wiki/Circular_buffer">ring buffer</a>-like data structure to evict <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#First_in_first_out_(FIFO)">least recently created</a> user records first.</p>
<p>Crates such as <a href="https://docs.rs/arraydeque/0.4.3/arraydeque/"><code>arraydeque</code></a> or <a href="http://contain-rs.github.io/linked-hash-map/linked_hash_map/"><code>linked_hash_map</code></a> can be used to limit the number of stored entries.</p>
<p>Other policies such as <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)">LRU</a> eviction can be used as well. Another option would be to restrict the number of users the application can handle or accept state modifications made only by the limited subset of users with write permissions.</p>
<p>An illustration of vigilant memory management can be found in the <a href="https://github.com/fluencelabs/fun/tree/master/tic-tac-toe">tic-tac-toe</a> example game.</p>
<a class="header" href="#shrinking-app-code-size" id="shrinking-app-code-size"><h2>Shrinking app code size</h2></a>
<p>In most cases, there is no need to worry about the size of the generated WebAssembly code. However, techniques for reducing the WebAssembly package size can be found in the <a href="https://rustwasm.github.io/book/reference/code-size.html">Rust and WebAssembly book</a>. Another option would be to avoid the use of the Fluence SDK and implement required API functions from scratch.</p>
<a class="header" href="#panics" id="panics"><h2>Panics</h2></a>
<p>Backend applications are allowed to panic, for example, if an <code>unwrap</code> or <code>expect</code> call fails. At the current moment, the returned error message will not be too informative in this case:</p>
<pre><code>{
   &quot;Error&quot;:{
      &quot;code&quot;:&quot;TrapError&quot;,
      &quot;message&quot;:&quot;Function invoke with args: List(1117056, 53) was failed&quot;,
      &quot;cause&quot;:&quot;Function invoke with args: List(1117056, 53) was failed&quot;
   }
}
</code></pre>
<p>However, the application will remain in consistent state and will be able to process other requests.</p>
<a class="header" href="#backend-cc-sdk-overview" id="backend-cc-sdk-overview"><h1>Backend C/C++ SDK overview</h1></a>
<a class="header" href="#compilation-cc-to-webassembly" id="compilation-cc-to-webassembly"><h2>Compilation C/C++ to Webassembly</h2></a>
<p>There are two main requirements for provided Webassembly modules:</p>
<ul>
<li>they must have three export functions: <code>allocate</code>, <code>deallocate</code>, <code>invoke</code></li>
<li>they don't have other import functions except <code>write</code> and <code>flush</code> from logger module</li>
</ul>
<p>You can find more detailed info about requirements in <a href="backend/c_cpp/../internals.html">internals</a> section of this guide. But compilation of C/C++ to Webassembly often generates modules with several syscall imports. We have tried to simplify the compilation process for C/C++ as much as possible.</p>
<p>There are few possible ways of compilation of C/C++ code to Webassembly, and two of them are most suitable for our platform:</p>
<ul>
<li>by wasm32-unknown-wasi target</li>
<li>by wasm32-unknown-unknown target</li>
</ul>
<a class="header" href="#wasm32-unknown-wasi" id="wasm32-unknown-wasi"><h3>wasm32-unknown-wasi</h3></a>
<p>Compilation with WASI-sysroot is quite simple:</p>
<ol>
<li>
<p>WASI sysroot could be obtained by compilation of <a href="https://github.com/CraneStation/wasi-sysroot">wasi-sysroot</a> or could be done by downloading and installing it from <a href="https://github.com/CraneStation/wasi-sdk/releases">releases</a> (we recommend to use the latest one).</p>
</li>
<li>
<p>Given WASI in /opt/wasi-sdk compilation could be done by</p>
</li>
</ol>
<pre><code class="language-bash">~ $ clang --sysroot=/opt/wasi-sdk/ --target=wasm32-unknown-wasi -o module.wasm -nostartfiles -fvisibility=hidden -Wl,--no-entry,--export=allocate,--export=deallocate,--export=invoke,--allow-undefined -- *.c
</code></pre>
<p>There <code>--export</code> directives for linker manage it to make three functions exported from module and <code>--allow-undefined</code> used to make it possible to import <code>write</code> and <code>flush</code> functions.</p>
<a class="header" href="#wasm32-unknown-unknown" id="wasm32-unknown-unknown"><h3>wasm32-unknown-unknown</h3></a>
<p>Compilation for wasm32-unknown-unknown is more complicated and suggests building sysroot first:</p>
<ol>
<li>First of all it needs to install the latest stable llvm 8.x that supports Webassembly. On Ubuntu it could be done by following commands (more detailed overview of llvm installation could be found <a href="http://apt.llvm.org">here</a>):</li>
</ol>
<pre><code class="language-bash"># update sources with latest llvm mirror
~ $ echo &quot;deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic main&quot; &gt;&gt; /etc/apt/sources.list.d/llvm.list &amp;&amp; \
~ $ echo &quot;deb-src http://apt.llvm.org/bionic/ llvm-toolchain-bionic main&quot; &gt;&gt; /etc/apt/sources.list.d/llvm.list &amp;&amp; \

# retrieve the archive signature
~ $ wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | apt-key add - &amp;&amp; \

~ $ apt-get update

# install all key llvm packages
~ $ apt-get install -y clang-8 lldb-8 lld-8 libllvm-8-ocaml-dev libllvm8 llvm-8 llvm-8-dev llvm-8-doc llvm-8-examples llvm-8-runtime    clang-8 clang-tools-8 clang-8-doc libclang-common-8-dev libclang-8-dev libclang1-8 clang-format-8 python-clang-8 libc++-8-dev libc++abi-8-dev

# update environment variable with path to newly installed llvm
~ $ echo PATH=&quot;/usr/lib/llvm-8/bin:${PATH}&quot;
~ $ echo LD_LIBRARY_PATH=&quot;/usr/lib/llvm-8/lib:${LD_LIBRARY_PATH}&quot;
</code></pre>
<ol start="2">
<li>Configure and build musl (it is a C standard library)</li>
</ol>
<pre><code class="language-bash"># create directory for builds
~ $ mkdir ~/build &amp;&amp; cd build

# clone our special version of musl
~ $ git clone https://github.com/fluencelabs/musl.git &amp;&amp; cd musl

# configure musl build for wasm32-unknown-unknown-wasm target
~ $ ./configure CC=clang CFLAGS=&quot;--target=wasm32-unknown-unknown-wasm -O3&quot; --prefix=/sysroot --enable-debug wasm32

# build musl in 8 threads
~ $ make -C /build/musl -j 8 install CROSS_COMPILE=llvm-

# make a directory for our sysroot
~ $ mkdir /opt/wasm-sysroot

# copy compiled musl to it
~ $ cp /src/musl/arch/wasm32/libc.imports /opt/wasm-sysroot/lib/
</code></pre>
<ol start="3">
<li>Build compiler-rt</li>
</ol>
<pre><code class="language-bash">~ $ cd ~/build
git clone https://github.com/llvm-mirror/compiler-rt.git &amp;&amp; cd compiler-rt

# configure compiler-rt with cland for wasm32-unknown-unknown-wasm target
~ $ CC=clang cmake -DCMAKE_SYSROOT=/sysroot -DCOMPILER_RT_DEFAULT_TARGET_TRIPLE=wasm32-unknown-unknown-wasm -DCMAKE_C_COMPILER_WORKS=1 --target /src/compiler-rt/lib/builtins

# build compiler-rt
~ $ make

# copy compiler compiler-rt to clang libs
~ $ cp lib/*/libclang_rt.builtins-*.a /usr/lib/llvm-8/lib/clang/8.0.0/lib/
</code></pre>
<p>Finally, we have newly builded sysroot and could compile C/C++ code to Wasm using similar command as for WASI target:</p>
<pre><code class="language-bash">~ $ clang --sysroot=/opt/wasm-sysroot --target=wasm32-unknown-unknown -o module.wasm -nostartfiles -fvisibility=hidden -Wl,--no-entry,--export=allocate,--export=deallocate,--export=invoke,--allow-undefined -- *.c
</code></pre>
<a class="header" href="#creating-a-hello-world-backend-app-for-fluence" id="creating-a-hello-world-backend-app-for-fluence"><h2>Creating a Hello World backend app for Fluence</h2></a>
<p>For a backend to be compatible with the Fluence network, it should follow aforementioned conventions to let Fluence nodes run your code correctly. To simplify the application process creating, we have developed the С/С++ SDK, dockerfile which includes all build internals, and the template project for C and C++. Let's learn how to use it!</p>
<a class="header" href="#building-app-written-on-c" id="building-app-written-on-c"><h3>Building app written on C</h3></a>
<p>The most simplest way of building application on C is using our template project that could be downloaded <a href="https://github.com/fluencelabs/c-template">here</a>. It includes sdk, Makefile and main.c file with <code>invoke</code> function defined. For simplicity С/С++ SDK is distributed as source code files not a binary.</p>
<p>Let's open main.c in your favorite editor and write some code:</p>
<pre><code class="language-C++">#include &quot;sdk/allocator.h&quot;
#include &quot;sdk/logger.h&quot;
#include &lt;string.h&gt;

const char *const greeting = &quot;Hello world! From &quot;;
const int RESPONSE_SIZE_BYTES = 4;

char *invoke(const char *str, int length) {
    const size_t greeting_length = strlen(greeting);
    const size_t response_length = length + greeting_length;

    char *response = (char *)allocate(response_length + RESPONSE_SIZE_BYTES);

    wasm_log(str, length);

    // (1)
    for(int i = 0; i &lt; RESPONSE_SIZE_BYTES; ++i) {
        response[i] = (response_length &gt;&gt; 8*i) &amp; 0xFF;
    }

    // (2)
    memcpy(response + RESPONSE_SIZE_BYTES, greeting, greeting_length);
    memcpy(response + RESPONSE_SIZE_BYTES + greeting_length, str, length);

    return response;
}
</code></pre>
<p>This invoke function receives pointer to some string and its length and append it to <code>Hello world! From</code> string. To return result from the invoke function it needs to prepend it with its length written in little endian. In this example it is done in (1) and then in (2) the rest of result is copying.</p>
<p>This app could be built either with docker by</p>
<pre><code class="language-bash">~ $ docker-compose up
</code></pre>
<p>or by Makefile</p>
<pre><code class="language-bash">~ $ make CC=&lt;path_to_clang&gt; SYSROOT=&lt;path_to_sysroot&gt; TARGET_TRIPLE=&lt;path_to_target_triple&gt;
</code></pre>
<p>The complete Hello World example written on C could be found <a href="https://github.com/fluencelabs/tutorials/tree/master/hello-world/app-logger-c">here</a>.</p>
<a class="header" href="#building-app-written-on-c-1" id="building-app-written-on-c-1"><h3>Building app written on C++</h3></a>
<p>С++ application could be created in a similar ways as a C by using this <a href="https://github.com/fluencelabs/cpp-template">template</a>.</p>
<p>Let's open main.cpp in your favorite editor and write some code:</p>
<pre><code class="language-C++">#include &quot;sdk/sdk.h&quot;
#include &lt;string.h&gt;

const std::string greeting = &quot;Hello world! From &quot;;

extern &quot;C&quot; char *invoke(char *str, int length) {
    const std::string request = sdk::read_request&lt;std::string&gt;(str, length);
    const std::string response = greeting + request;

    sdk::wasm_log(response);

    return sdk::write_response(response);
}
</code></pre>
<p>In this example, we have some excess allocation (while transforming a raw supplied string to std::string and while appending two strings) and to reduce this overhead scheme from C application could be used.</p>
<p>The complete Hello World example written on C++ could be found <a href="https://github.com/fluencelabs/tutorials/tree/master/hello-world/app-logger-cpp">here</a>.</p>
<a class="header" href="#backend-cc-sdk-overview-1" id="backend-cc-sdk-overview-1"><h1>Backend C/C++ SDK overview</h1></a>
<a class="header" href="#compilation-cc-to-webassembly-1" id="compilation-cc-to-webassembly-1"><h2>Compilation C/C++ to Webassembly</h2></a>
<p>There are two main requirements for provided Webassembly modules:</p>
<ul>
<li>they must have three export functions: <code>allocate</code>, <code>deallocate</code>, <code>invoke</code></li>
<li>they don't have other import functions except <code>write</code> and <code>flush</code> from logger module</li>
</ul>
<p>You can find more detailed info about requirements in <a href="backend/c_cpp/../internals.html">internals</a> section of this guide. But compilation of C/C++ to Webassembly often generates modules with several syscall imports. We have tried to simplify the compilation process for C/C++ as much as possible.</p>
<p>There are few possible ways of compilation of C/C++ code to Webassembly, and two of them are most suitable for our platform:</p>
<ul>
<li>by wasm32-unknown-wasi target</li>
<li>by wasm32-unknown-unknown target</li>
</ul>
<a class="header" href="#wasm32-unknown-wasi-1" id="wasm32-unknown-wasi-1"><h3>wasm32-unknown-wasi</h3></a>
<p>Compilation with WASI-sysroot is quite simple:</p>
<ol>
<li>
<p>WASI sysroot could be obtained by compilation of <a href="https://github.com/CraneStation/wasi-sysroot">wasi-sysroot</a> or could be done by downloading and installing it from <a href="https://github.com/CraneStation/wasi-sdk/releases">releases</a> (we recommend to use the latest one).</p>
</li>
<li>
<p>Given WASI in /opt/wasi-sdk compilation could be done by</p>
</li>
</ol>
<pre><code class="language-bash">~ $ clang --sysroot=/opt/wasi-sdk/ --target=wasm32-unknown-wasi -o module.wasm -nostartfiles -fvisibility=hidden -Wl,--no-entry,--export=allocate,--export=deallocate,--export=invoke,--allow-undefined -- *.c
</code></pre>
<p>There <code>--export</code> directives for linker manage it to make three functions exported from module and <code>--allow-undefined</code> used to make it possible to import <code>write</code> and <code>flush</code> functions.</p>
<a class="header" href="#wasm32-unknown-unknown-1" id="wasm32-unknown-unknown-1"><h3>wasm32-unknown-unknown</h3></a>
<p>Compilation for wasm32-unknown-unknown is more complicated and suggests building sysroot first:</p>
<ol>
<li>First of all it needs to install the latest stable llvm 8.x that supports Webassembly. On Ubuntu it could be done by following commands (more detailed overview of llvm installation could be found <a href="http://apt.llvm.org">here</a>):</li>
</ol>
<pre><code class="language-bash"># update sources with latest llvm mirror
~ $ echo &quot;deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic main&quot; &gt;&gt; /etc/apt/sources.list.d/llvm.list &amp;&amp; \
~ $ echo &quot;deb-src http://apt.llvm.org/bionic/ llvm-toolchain-bionic main&quot; &gt;&gt; /etc/apt/sources.list.d/llvm.list &amp;&amp; \

# retrieve the archive signature
~ $ wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | apt-key add - &amp;&amp; \

~ $ apt-get update

# install all key llvm packages
~ $ apt-get install -y clang-8 lldb-8 lld-8 libllvm-8-ocaml-dev libllvm8 llvm-8 llvm-8-dev llvm-8-doc llvm-8-examples llvm-8-runtime    clang-8 clang-tools-8 clang-8-doc libclang-common-8-dev libclang-8-dev libclang1-8 clang-format-8 python-clang-8 libc++-8-dev libc++abi-8-dev

# update environment variable with path to newly installed llvm
~ $ echo PATH=&quot;/usr/lib/llvm-8/bin:${PATH}&quot;
~ $ echo LD_LIBRARY_PATH=&quot;/usr/lib/llvm-8/lib:${LD_LIBRARY_PATH}&quot;
</code></pre>
<ol start="2">
<li>Configure and build musl (it is a C standard library)</li>
</ol>
<pre><code class="language-bash"># create directory for builds
~ $ mkdir ~/build &amp;&amp; cd build

# clone our special version of musl
~ $ git clone https://github.com/fluencelabs/musl.git &amp;&amp; cd musl

# configure musl build for wasm32-unknown-unknown-wasm target
~ $ ./configure CC=clang CFLAGS=&quot;--target=wasm32-unknown-unknown-wasm -O3&quot; --prefix=/sysroot --enable-debug wasm32

# build musl in 8 threads
~ $ make -C /build/musl -j 8 install CROSS_COMPILE=llvm-

# make a directory for our sysroot
~ $ mkdir /opt/wasm-sysroot

# copy compiled musl to it
~ $ cp /src/musl/arch/wasm32/libc.imports /opt/wasm-sysroot/lib/
</code></pre>
<ol start="3">
<li>Build compiler-rt</li>
</ol>
<pre><code class="language-bash">~ $ cd ~/build
git clone https://github.com/llvm-mirror/compiler-rt.git &amp;&amp; cd compiler-rt

# configure compiler-rt with cland for wasm32-unknown-unknown-wasm target
~ $ CC=clang cmake -DCMAKE_SYSROOT=/sysroot -DCOMPILER_RT_DEFAULT_TARGET_TRIPLE=wasm32-unknown-unknown-wasm -DCMAKE_C_COMPILER_WORKS=1 --target /src/compiler-rt/lib/builtins

# build compiler-rt
~ $ make

# copy compiler compiler-rt to clang libs
~ $ cp lib/*/libclang_rt.builtins-*.a /usr/lib/llvm-8/lib/clang/8.0.0/lib/
</code></pre>
<p>Finally, we have newly builded sysroot and could compile C/C++ code to Wasm using similar command as for WASI target:</p>
<pre><code class="language-bash">~ $ clang --sysroot=/opt/wasm-sysroot --target=wasm32-unknown-unknown -o module.wasm -nostartfiles -fvisibility=hidden -Wl,--no-entry,--export=allocate,--export=deallocate,--export=invoke,--allow-undefined -- *.c
</code></pre>
<a class="header" href="#creating-a-hello-world-backend-app-for-fluence-1" id="creating-a-hello-world-backend-app-for-fluence-1"><h2>Creating a Hello World backend app for Fluence</h2></a>
<p>For a backend to be compatible with the Fluence network, it should follow aforementioned conventions to let Fluence nodes run your code correctly. To simplify the application process creating, we have developed the С/С++ SDK, dockerfile which includes all build internals, and the template project for C and C++. Let's learn how to use it!</p>
<a class="header" href="#building-app-written-on-c-2" id="building-app-written-on-c-2"><h3>Building app written on C</h3></a>
<p>The most simplest way of building application on C is using our template project that could be downloaded <a href="https://github.com/fluencelabs/c-template">here</a>. It includes sdk, Makefile and main.c file with <code>invoke</code> function defined. For simplicity С/С++ SDK is distributed as source code files not a binary.</p>
<p>Let's open main.c in your favorite editor and write some code:</p>
<pre><code class="language-C++">#include &quot;sdk/allocator.h&quot;
#include &quot;sdk/logger.h&quot;
#include &lt;string.h&gt;

const char *const greeting = &quot;Hello world! From &quot;;
const int RESPONSE_SIZE_BYTES = 4;

char *invoke(const char *str, int length) {
    const size_t greeting_length = strlen(greeting);
    const size_t response_length = length + greeting_length;

    char *response = (char *)allocate(response_length + RESPONSE_SIZE_BYTES);

    wasm_log(str, length);

    // (1)
    for(int i = 0; i &lt; RESPONSE_SIZE_BYTES; ++i) {
        response[i] = (response_length &gt;&gt; 8*i) &amp; 0xFF;
    }

    // (2)
    memcpy(response + RESPONSE_SIZE_BYTES, greeting, greeting_length);
    memcpy(response + RESPONSE_SIZE_BYTES + greeting_length, str, length);

    return response;
}
</code></pre>
<p>This invoke function receives pointer to some string and its length and append it to <code>Hello world! From</code> string. To return result from the invoke function it needs to prepend it with its length written in little endian. In this example it is done in (1) and then in (2) the rest of result is copying.</p>
<p>This app could be built either with docker by</p>
<pre><code class="language-bash">~ $ docker-compose up
</code></pre>
<p>or by Makefile</p>
<pre><code class="language-bash">~ $ make CC=&lt;path_to_clang&gt; SYSROOT=&lt;path_to_sysroot&gt; TARGET_TRIPLE=&lt;path_to_target_triple&gt;
</code></pre>
<p>The complete Hello World example written on C could be found <a href="https://github.com/fluencelabs/tutorials/tree/master/hello-world/app-logger-c">here</a>.</p>
<a class="header" href="#building-app-written-on-c-3" id="building-app-written-on-c-3"><h3>Building app written on C++</h3></a>
<p>С++ application could be created in a similar ways as a C by using this <a href="https://github.com/fluencelabs/cpp-template">template</a>.</p>
<p>Let's open main.cpp in your favorite editor and write some code:</p>
<pre><code class="language-C++">#include &quot;sdk/sdk.h&quot;
#include &lt;string.h&gt;

const std::string greeting = &quot;Hello world! From &quot;;

extern &quot;C&quot; char *invoke(char *str, int length) {
    const std::string request = sdk::read_request&lt;std::string&gt;(str, length);
    const std::string response = greeting + request;

    sdk::wasm_log(response);

    return sdk::write_response(response);
}
</code></pre>
<p>In this example, we have some excess allocation (while transforming a raw supplied string to std::string and while appending two strings) and to reduce this overhead scheme from C application could be used.</p>
<p>The complete Hello World example written on C++ could be found <a href="https://github.com/fluencelabs/tutorials/tree/master/hello-world/app-logger-cpp">here</a>.</p>
<a class="header" href="#best-practices-for-cc-backend-applications" id="best-practices-for-cc-backend-applications"><h1>Best practices for C/C++ backend applications</h1></a>
<a class="header" href="#request-routing-1" id="request-routing-1"><h2>Request routing</h2></a>
<p>Fluence does not provide a sane request routing yet – only one function can be marked as an entry point. This means that each developer has to independently decide on an input argument format, parse this argument in the entry point function, and call other functions based on the passed action selector.</p>
<p>One option would be to use JSON serialization (for example, provided by <a href="https://github.com/kgabis/parson">parson</a>) to wrap input data.</p>
<a class="header" href="#syscall-imports" id="syscall-imports"><h2>Syscall imports</h2></a>
<p>Sometimes imports of syscall could appear in compiled wasm binary. It happens mostly by including some libraries (like <code>stdio.h</code>).
Checking the appearance of such imports could be done by translating wasm (binary format) to wast (test format) (e.g. by <a href="https://github.com/WebAssembly/wabt">wabt</a>) and viewing manually for imports. All possible imports are these two:</p>
<pre><code>(import &quot;logger&quot; &quot;write&quot; (func $__write (type 0)))
(import &quot;logger&quot; &quot;flush&quot; (func $__flush (type 7)))
</code></pre>
<p>They are needed for logger. Also note, almost always imports of syscall could be replaced in text format to empty function.</p>
<a class="header" href="#carefully-tracking-compiler-and-linker-warnings" id="carefully-tracking-compiler-and-linker-warnings"><h2>Carefully tracking compiler and linker warnings</h2></a>
<p>Generally, it is good idea to investigate all tracking compiler and linker warnings and try to get rid of them. But especially it is important during compilation to Webassembly. Let's review one of these seemingly innocuous warnings that look like this:</p>
<pre><code class="language-bash">wasm-ld: warning: function signature mismatch: qsort
&gt;&gt;&gt; defined as (i32, i32, i32, i32) -&gt; i32 in geo.o
&gt;&gt;&gt; defined as (i32, i32, i32, i32) -&gt; void in /opt/wasi-sdk/share/sysroot/lib/wasm32-wasi/libc.a(qsort.o)
</code></pre>
<p>The reason for this error is lacking of <code>#include &lt;stdlib.h&gt;</code> directive. For some reason, a compiler could use signature of this function that returns <code>i32</code> whereas the original function doesn't return anything. The result is an unnecessary <code>drop</code> instruction after each call of such function. It makes resulted binary incorrect for Wasm validator and, finally, it couldn't be run on Fluence.</p>
<a class="header" href="#shrinking-app-code-size-1" id="shrinking-app-code-size-1"><h2>Shrinking app code size</h2></a>
<p>In most cases, there is no need to worry about the size of the generated WebAssembly code. However, there are some common techniques for reducing the WebAssembly package size:</p>
<ul>
<li>using <code>-O3</code> option for aggressive optimization</li>
<li>using <code>--strip-all</code> options of linker for strip all symbols from generated binary</li>
<li>not using <code>double float</code> and all functions that receive it as a parameter because it generates a lot of wasm instructions and imports to compiler-rt lib.</li>
</ul>
<a class="header" href="#coming-soon" id="coming-soon"><h3>Coming soon</h3></a>
<a class="header" href="#debugging-with-local-fluence-node" id="debugging-with-local-fluence-node"><h3>Debugging with local Fluence node</h3></a>
<p>Keep your write-test-fix cycle short by debugging your application locally, without waiting for deployment and network.</p>
<a class="header" href="#requirements-2" id="requirements-2"><h2>Requirements</h2></a>
<p>You will need <a href="https://docs.docker.com/install/">Docker</a> installed.</p>
<a class="header" href="#how-to-1" id="how-to-1"><h2>How to</h2></a>
<p>NOTE: For this guide, you will need compiled Wasm code. <a href="backend/../quickstart/backend.html#compiling-to-webassembly">Read here</a> to learn about compilation to Wasm.</p>
<a class="header" href="#start-your-application" id="start-your-application"><h3>Start your application</h3></a>
<p>Run the following command in terminal, it will start your application in a Docker container:</p>
<pre><code>docker run --rm -v /path/to/your/code.wasm:/code/code.wasm -p 30000:30000 fluencelabs/frun
</code></pre>
<p>To connect to your application from JS client use <code>directConnect</code> method:</p>
<pre><code class="language-javascript">import * as fluence from &quot;fluence&quot;;
...
let appId = 1
fluence.directConnect(&quot;localhost&quot;, 30000, appId);
</code></pre>
<p><code>appId</code> could be any number. You do not need to specify the correct <code>appId</code> for local testing.</p>
<p>NOTE: Use <code>connect</code> method instead of <code>directConnect</code> for an application deployed in the Fluence network. <a href="backend/../frontend/javascript.html">Read here</a> to learn how to interact with deployed applications.</p>
<p>Send request <code>val request = session.request(&quot;Fluence&quot;)</code> to <a href="https://github.com/fluencelabs/tutorials/tree/master/hello-world">hello-world app</a> through JavaScript client and we can see in docker logs:</p>
<pre><code>[Mon Apr 22 16:03:31 MSK 2019, info, Main$] Tx request. appId: 1
[Mon Apr 22 16:03:31 MSK 2019, info, Main$] Tx: 'Fluence'
INFO  [hello_world2_2018] Fluence has been successfully greeted
</code></pre>
<p><code>Tx: 'Fluence'</code> is our request, <code>INFO [hello_world2_2018] Fluence has been successfully greeted</code> is logs from code. How to write logs from code code you can see in <a href="backend/index.html">backend guides</a>.</p>
<p>After this get response <code>request.result()</code>. And we will see the result:</p>
<pre><code>[Mon Apr 22 16:03:31 MSK 2019, info, Main$] Query request. appId: 1, path: sessionId/0, data: Some()
[Mon Apr 22 16:03:31 MSK 2019, info, TxProcessor] Queried result: Hello, world! From user Fluence
</code></pre>
<p>NOTE: You can also send requests from command line with curl, read <a href="backend/../frontend/http.html">here</a> for more.</p>
<a class="header" href="#backend-internals" id="backend-internals"><h1>Backend internals</h1></a>
<a class="header" href="#application-interface" id="application-interface"><h2>Application interface</h2></a>
<p>A backend application is allowed to consist of more than one WebAssembly module (provided they have different names), but only one of those modules can be called by the state machine. Note that this module <strong>should not</strong> have the module name section. Additionally, every backend application that is going to be deployed to the Fluence network is <strong>expected to</strong> export three functions – <code>invoke()</code>, <code>allocate()</code>, and <code>deallocate()</code>:</p>
<pre><code class="language-Rust">#[no_mangle]
pub unsafe fn invoke(ptr: *mut u8, len: usize) -&gt; usize {
    ...
}

#[no_mangle]
pub unsafe fn allocate(size: usize) -&gt; NonNull&lt;u8&gt; {
    ...
}

#[no_mangle]
pub unsafe fn deallocate(ptr: *mut u8, size: usize) {
    ...
}
</code></pre>
<p>Note that <code>#[no_mangle]</code> and <code>pub unsafe</code> signature parts force these functions to be exported by WebAssembly (refer to this <a href="https://internals.rust-lang.org/t/precise-semantics-of-no-mangle/4098">discussion</a> for more info). In <em>wast</em> format, these functions are expected to have the following signatures:</p>
<pre><code>(func (export &quot;invoke&quot;) (param $buffer i32) (param $size i32) (result i32))

(func (export &quot;allocate&quot;) (param $size i32) (result i32))

(func (export &quot;deallocate&quot;) (param $address i32) (param $size i32) (return))
</code></pre>
<p>The <code>invoke()</code> function is the main entry point to the deployed application. It takes two <code>i32</code> params – a pointer to the byte array stored in the WebAssembly memory and the byte array size. If the state machine needs to call the <code>invoke()</code> function with no arguments, it passes two null values for the pointer and the size argument. To return the result, the <code>invoke()</code> function returns a pointer to the WebAssembly memory region where the first 4 bytes represent the size of the result buffer, and the next <code>size</code> bytes represent the result buffer itself.</p>
<p>The <code>allocate()</code> function is responsible for allocating a region of memory where the state machine can write the data which should be passed to the application. Once the region is allocated, the application should not overwrite it until a corresponding <code>deallocate()</code> call is made. The <code>allocate()</code> function takes an <code>i32</code> parameter which specifies the size of the region, and returns a pointer to the allocated region in the WebAssembly memory.</p>
<p>The <code>deallocate()</code> function is responsible for memory deallocation. It takes two <code>i32</code> arguments – the address of the memory region that should be deallocated and its size.</p>
<a class="header" href="#request-response-lifecycle" id="request-response-lifecycle"><h2>Request-response lifecycle</h2></a>
<p>Once the state machine receives a transaction block, it forwards each transaction to the backend application and awaits results of its execution. The transaction processing lifecycle can be described as follows:</p>
<ol>
<li>
<p>The state machine calls the <code>allocate()</code> function exported by the application and passes to it the size of the memory region that the backend application should allocate for the input. The  <code>allocate()</code> function returns the offset in the WebAssembly memory where the input should be written to.</p>
</li>
<li>
<p>The state machine writes the input at the offset returned by the <code>allocate()</code> function.</p>
</li>
<li>
<p>The state machine calls the <code>invoke()</code> function exported by the application and passes to it the offset where the input was written to and the size of the input in bytes.</p>
</li>
<li>
<p>The state machine synchronously waits for the <code>invoke()</code> function to complete. The <code>invoke()</code> function returns a pointer to the WebAssembly memory region storing the returned result. The state machine reads the returned result and caches it before sending back to the client.</p>
</li>
<li>
<p>The state machine uses the <code>deallocate()</code> function exported by the application to free WebAssembly memory regions used to store input and output data.</p>
</li>
</ol>
<a class="header" href="#unmanaged-application-example" id="unmanaged-application-example"><h2>Unmanaged application example</h2></a>
<p>Here is how a simple <a href="https://github.com/fluencelabs/tutorials/tree/master/hello-world/app-nosdk-rust-2018">hello world</a> application written in Rust can be implemented without the Fluence SDK:</p>
<pre><code class="language-Rust">#![feature(allocator_api)]

use std::alloc::{Alloc, Global, Layout};
use std::mem;
use std::num::NonZeroUsize;
use std::ptr::{self, NonNull};

#[no_mangle]
pub unsafe fn invoke(ptr: *mut u8, len: usize) -&gt; NonNull&lt;u8&gt; {
    let raw_string = Vec::from_raw_parts(ptr, len, len);
    let user_name = String::from_utf8(raw_string).unwrap();

    let result = format!(&quot;Hello, world! -- {}&quot;, user_name);
    const RESULT_SIZE_BYTES: usize = 4;

    let result_len = result.len();
    let total_len = result_len
        .checked_add(RESULT_SIZE_BYTES)
        .expect(&quot;usize overflow occurred&quot;);

    // converts array size to bytes in little-endian
    let len_as_bytes: [u8; RESULT_SIZE_BYTES] = mem::transmute((result_len as u32).to_le());

    // allocates a new memory region for the result
    let result_ptr = allocate(total_len);

    // copies length of array to memory
    ptr::copy_nonoverlapping(
        len_as_bytes.as_ptr(),
        result_ptr.as_ptr(),
        RESULT_SIZE_BYTES,
    );

    // copies array to memory
    ptr::copy_nonoverlapping(
        result.as_ptr(),
        result_ptr.as_ptr().add(RESULT_SIZE_BYTES),
        result_len,
    );

    result_ptr
}

#[no_mangle]
pub unsafe fn allocate(size: usize) -&gt; NonNull&lt;u8&gt; {
    let non_zero_size =
        NonZeroUsize::new(size).expect(&quot;[Error]: allocation of zero bytes is not allowed.&quot;);
    let layout: Layout = Layout::from_size_align(non_zero_size.get(), mem::align_of::&lt;u8&gt;())
        .unwrap_or_else(|_| panic!(&quot;[Error]: layout creation failed while allocation&quot;));
    Global
        .alloc(layout)
        .unwrap_or_else(|_| panic!(&quot;[Error]: allocation of {} bytes failed&quot;, size))
}

#[no_mangle]
pub unsafe fn deallocate(ptr: NonNull&lt;u8&gt;, size: usize) {
    let non_zero_size =
        NonZeroUsize::new(size).expect(&quot;[Error]: deallocation of zero bytes is not allowed.&quot;);
    let layout = Layout::from_size_align(non_zero_size.get(), mem::align_of::&lt;u8&gt;())
        .unwrap_or_else(|_| panic!(&quot;[Error]: layout creation failed while deallocation&quot;));;
    Global.dealloc(ptr, layout);
}
</code></pre>
<a class="header" href="#coming-soon-1" id="coming-soon-1"><h3>Coming soon</h3></a>
<a class="header" href="#frontend-guide" id="frontend-guide"><h1>Frontend Guide</h1></a>
<p>In the presence of a backend we able to interact with written code through HTTP API. It opens up a possibility to build complex decentralized systems in a standard client-server (or frontend-backend) way.</p>
<ul>
<li><a href="frontend/javascript.html">JavaScript client</a></li>
<li><a href="frontend/http.html">HTTP API</a></li>
</ul>
<p>Useful links:</p>
<ul>
<li><a href="frontend/../backend/index.html">Backend Guide</a></li>
<li><a href="frontend/../quickstart/web.html">Frontend Quickstart</a></li>
<li><a href="frontend/../backend/debugging.html">Debugger</a>: test you frontend without deploying backend in Fluence network</li>
</ul>
<a class="header" href="#simple-to-use" id="simple-to-use"><h1>Simple to use</h1></a>
<p>Fluence client is designed to be the simplest way possible to make requests to the Fluence network. You don't need anything to know about the internals of Fluence, just use it like other common libraries.</p>
<a class="header" href="#installation" id="installation"><h1>Installation</h1></a>
<p><code>npm install --save fluence</code></p>
<a class="header" href="#usage" id="usage"><h1>Usage</h1></a>
<p>We need to know three constants to work with Fluence:</p>
<pre><code class="language-javascript">// address to Fluence contract in Ethereum blockchain. 
let contractAddress = &quot;0xeFF91455de6D4CF57C141bD8bF819E5f873c1A01&quot;;

// set ethUrl to `undefined` to use MetaMask instead of Ethereum node
let ethUrl = &quot;http://rinkeby.fluence.one:8545/&quot;;

// application to interact with that stored in Fluence contract
let appId = &quot;43&quot;;
</code></pre>
<p>Let's create a session with Fluence and start to send requests.</p>
<pre><code class="language-javascript">import * as fluence from &quot;fluence&quot;;

let session;

fluence.connect(contractAddress, appId, ethUrl).then((s) =&gt; {
    console.log(&quot;Session created&quot;);
    session = s;
});
</code></pre>
<p>Need to remember that all interactions are asynchronous, so we always work with promises.</p>
<p>Send request to backend:</p>
<pre><code class="language-javascript">let request = s.request(&quot;Hello, Fluence!&quot;)
</code></pre>
<p>Sending a request and getting a response is different operations, because of the decentralized architecture of Fluence network. Call another method to get a response:</p>
<pre><code class="language-javascript">request.result()
    .then((r) =&gt; console.log(r.asString()))
</code></pre>
<p><code>asString()</code> method was called because in the raw form a response is bytes in hex representation.</p>
<p>That's all! Based on this API a developer can build client-server application any level of complexity.</p>
<a class="header" href="#tips-and-tricks" id="tips-and-tricks"><h1>Tips and Tricks</h1></a>
<a class="header" href="#sign-all-requests" id="sign-all-requests"><h3>Sign all requests</h3></a>
<p>You can add private key as a fourth argument in <code>connect</code> method if it is needed to check the correctness of signature on the side of a backend (authorization).</p>
<pre><code class="language-javascript">fluence.connect(contractAddress, appId, ethUrl, privateKey)
</code></pre>
<p>More about authentication on a backend side: <a href="frontend/../backend/best_practices.html">Backend Guide: Best Practices</a></p>
<a class="header" href="#use-metamask" id="use-metamask"><h3>Use MetaMask</h3></a>
<p>Just left <code>ethUrl</code> argument as <code>undefined</code></p>
<pre><code class="language-javascript">fluence.connect(contractAddress, appId, undefined)
</code></pre>
<a class="header" href="#direct-connection-for-local-testing" id="direct-connection-for-local-testing"><h3>Direct connection for local testing</h3></a>
<p>Use <code>directConnect</code> to connect to local hosted node:</p>
<pre><code class="language-javascript">let appId = 41 // it is not important on local nodes, could be random number
fluence.directConnect(&quot;localhost&quot;, 30000, appId);
</code></pre>
<p>For more details and how to debug the code: []</p>
<a class="header" href="#fluence-http-protocol" id="fluence-http-protocol"><h1>Fluence HTTP protocol</h1></a>
<p>Fluence HTTP protocol is simple, and supports two main features: session-handling, and request ordering.</p>
<p>Given IP <code>1.2.3.4</code>, request with a tx would look like this</p>
<pre><code>curl 'http://1.2.3.4:25000/apps/2/tx' --data $'sessionId/0\nRequestBody'
</code></pre>
<ul>
<li><code>:25000</code> - default Fluence port</li>
<li><code>apps</code> - prefix for appId routing</li>
<li><code>2</code> - appId</li>
<li><code>tx</code> - suffix for all txs</li>
<li><code>sessionId</code> - random client-generated string, requests are ordered by that string</li>
<li><code>0</code> - requests counter, user for ordering, should be incremented sequentially, i.e., avoid number skipping</li>
<li>'\n'- separator between <code>sessionId/counter</code> and the request</li>
<li>'RequestBody' - could be anything, sent directly to your application</li>
</ul>
<p>So, the main thing to take away is a <code>sessionId/counter\nbody</code> format, and remember to increment requests counter sequentially, <strong>because Fluence will wait for all omitted request numbers. This is done to preserve strict ordering, so Fluence can guarantee request processing in the strict order.</strong></p>
<ul>
<li><a href="#fluence-miner-guide">Fluence miner guide</a>
<ul>
<li><a href="#how-mining-works">How mining works</a></li>
<li><a href="#how-to-become-a-fluence-miner">How to become a Fluence miner</a>
<ul>
<li><a href="#deploy-fluence-node-to-a-cloud">Deploy Fluence node to a cloud</a></li>
<li><a href="#deploy-fluence-node-locally">Deploy Fluence node locally</a></li>
</ul>
</li>
<li><a href="#how-to-check-if-node-is-registered">How to check if node is registered</a></li>
<li><a href="#private-nodes-and-application-pinning">Private nodes and application pinning</a>
<ul>
<li><a href="#private-nodes">Private nodes</a></li>
<li><a href="#application-pinning">Application pinning</a>
<ul>
<li><a href="#mixing-pinning-and-matching">Mixing pinning and matching</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#how-to-remove-a-node-from-the-fluence-smart-contract">How to remove a node from the Fluence smart contract</a></li>
<li><a href="#tips-and-tricks">Tips and tricks</a></li>
</ul>
</li>
</ul>
<a class="header" href="#fluence-miner-guide" id="fluence-miner-guide"><h1>Fluence miner guide</h1></a>
<p>Being a miner in Fluence network means that you will provide you computation power to host decentralized backends. In order to do that, you will need just a few things:</p>
<ol>
<li>A computer to run a Fluence node and workers on it</li>
<li>Installed and running Docker and <code>docker-compose</code></li>
<li>Installed python2 pip</li>
<li>An Ethereum light-client or full node connected to Rinkeby testnet</li>
<li>A Rinkeby Ethereum wallet topped up with some ETH to submit transactions</li>
</ol>
<a class="header" href="#how-mining-works" id="how-mining-works"><h2>How mining works</h2></a>
<p>The process is as follows:
You run a Docker image with Fluence node on your computer, then you register that node within Fluence smart contract by using Fluence CLI. On registration, you specify max number of backends you wish to host, so your node doesn't run out of resources.</p>
<p>After you registered your node within smart contract, it starts waiting to be included in an application cluster. That will happen when someone publishes an app and the Fluence smart contract will match that app to your node, and then send an Ethereum event that your node is listening to.</p>
<p>When node receives an event stating it's a part of an application cluster now, it will download application code from Swarm, and then run a Docker image with Fluence worker hosting that code.</p>
<a class="header" href="#how-to-become-a-fluence-miner" id="how-to-become-a-fluence-miner"><h2>How to become a Fluence miner</h2></a>
<p>The first step is to deploy a Fluence node. Deploy is automated, you can get scripts by cloning <a href="https://github.com/fluencelabs/fluence">Fluence repo</a>:</p>
<pre><code>git clone https://github.com/fluencelabs/fluence
</code></pre>
<a class="header" href="#deploy-fluence-node-to-a-cloud" id="deploy-fluence-node-to-a-cloud"><h3>Deploy Fluence node to a cloud</h3></a>
<p>It's an automated task, you will only need to specify your cloud instance IP addresses and your Ethereum wallet, and then run a (Fabric)[https://github.com/fabric/fabric] script.</p>
<p>First, let's install Fabric:</p>
<pre><code class="language-bash"># make use you're using python2
$ pip --version
pip 18.0 from &lt;...&gt; (python 2.7)
$ pip install Fabric==1.14.1
</code></pre>
<p>It should install fabric 1.14.1. <strong>Be careful not to install Fabric 2 as it's not current supported.</strong></p>
<p>Next, open <a href="../../tools/deploy/instances.json">fluence/tools/deploy/instances.json</a> in your favorite text editor, and modify config:</p>
<pre><code class="language-json">{
    &quot;&lt;ip1&gt;&quot;: {
        &quot;owner&quot;: &quot;&lt;owner-account1&gt;&quot;,
        &quot;key&quot;: &quot;&lt;secret-key1&gt;&quot;,
        &quot;api_port&quot;: &quot;&lt;port&gt;&quot;,
        &quot;capacity&quot;: &quot;&lt;max-num-of-apps&gt;&quot;
    },
    &quot;&lt;ip2&gt;&quot;: {
        &quot;owner&quot;: &quot;&lt;owner-account2&gt;&quot;,
        &quot;key&quot;: &quot;&lt;secret-key2&gt;&quot;,
        &quot;api_port&quot;: &quot;&lt;port&gt;&quot;,
        &quot;capacity&quot;: &quot;&lt;max-num-of-apps&gt;&quot;
    }
}

</code></pre>
<p>You can specify here several nodes, but for the sake of example, let's continue with a single node. After filling info in deploy_config.json, it should look similar to this:</p>
<pre><code class="language-json">{
    &quot;53.42.31.20&quot;: {
        &quot;owner&quot;: &quot;0x00a329c0648769a73afac7f9381e08fb43dbea72&quot;,
        &quot;key&quot;: &quot;4d5db4107d237df6a3d58ee5f70ae63d73d7658d4026f2eefd2f204c81682cb7&quot;,
        &quot;api_port&quot;: &quot;25000&quot;,
        &quot;capacity&quot;: 10
    }
}
</code></pre>
<p>You can also change user running setup commands on cloud instance by <code>env.user</code> to desired username.</p>
<pre><code class="language-python"># Set the username
env.user = &quot;root&quot;
</code></pre>
<p>Now, let's deploy Fluence node along with Geth and Swarm containers:</p>
<pre><code class="language-bash">$ fab deploy
</code></pre>
<p>At the end of the successful deployment you should see something like the following:</p>
<pre><code>[53.42.31.20] out: CONTRACT_ADDRESS=0xeFF91455de6D4CF57C141bD8bF819E5f873c1A01
[53.42.31.20] out: NAME=fluence-node-1
[53.42.31.20] out: HOST_IP=53.42.31.20
[53.42.31.20] out: EXTERNAL_HOST_IP=53.42.31.20
[53.42.31.20] out: OWNER_ADDRESS=0x00a329c0648769a73afac7f9381e08fb43dbea72
...
[53.42.31.20] out: Node container is started.
[53.42.31.20] out: CURRENT NODE = 1
[53.42.31.20] out: TENDERMINT_KEY=YAa6x36acTUIemAoejyplm+cUKe5rhTC1ArMPLMfvFY=
[53.42.31.20] out: API_PORT=25000
[53.42.31.20] out: CAPACITY=10
</code></pre>
<p>Here you have some useful information that you can use with Fluence CLI.</p>
<p>At the very end, you should see something like this:</p>
<pre><code>[53.42.31.20] out: [1/2]   Node synced. ---&gt; [00:00:00]
[53.42.31.20] out: [2/2]   Node added. ---&gt; [00:00:00]
[53.42.31.20] out: Node registered. Submitted transaction: 0x51e1dcf1cf20e136ce66d240e9897c329894c1084e55b13a4fab751fbaced981
</code></pre>
<p>That's the result of script registering your node within Fluence smart contract. You can see it in <a href="../../tools/deploy/scripts/compose.sh">compose.sh</a>:</p>
<pre><code class="language-bash">./fluence register \
        --node_ip           $EXTERNAL_HOST_IP \
        --tendermint_key    $TENDERMINT_KEY \
        --contract_address  $CONTRACT_ADDRESS \
        --account           $OWNER_ADDRESS \
        --secret_key        $PRIVATE_KEY \
        --api_port          $API_PORT \
        --capacity          $CAPACITY \
        --wait_syncing \
        --base64_tendermint_key
</code></pre>
<p>All environment variables used in the command are listed in the useful information above, so you can easily use them with Fluence CLI.</p>
<a class="header" href="#deploy-fluence-node-locally" id="deploy-fluence-node-locally"><h3>Deploy Fluence node locally</h3></a>
<p>If you wish to use your local computer to host Fluence node, you can do that by running <a href="../../tools/deploy/scripts/rinkeby-compose.sh">rinkeby-compose.sh</a> like this:</p>
<pre><code># ./rinkeby-compose.sh &lt;external-ip&gt; &lt;owner-address&gt; &lt;private-key&gt; &lt;api-port&gt; &lt;capacity&gt;
./rinkeby-compose.sh 53.42.31.20 0x00a329c0648769a73afac7f9381e08fb43dbea72 4d5db4107d237df6a3d58ee5f70ae63d73d7658d4026f2eefd2f204c81682cb7 25000 10
</code></pre>
<a class="header" href="#how-to-check-if-node-is-registered" id="how-to-check-if-node-is-registered"><h2>How to check if node is registered</h2></a>
<p>You can use <a href="../../cli/README.html">Fluence CLI</a> to query current state of network in Fluence smart contract like this:</p>
<pre><code class="language-bash">./fluence status
</code></pre>
<p><strong>Note:</strong> if your Ethereum node is remote, you can specify it's address via <code>--eth_url</code> option, like this:</p>
<pre><code class="language-bash">./fluence status --eth_url https://53.42.31.20:8545
</code></pre>
<p>You should see your Ethereum address under <code>owner</code> in <code>nodes</code> list. Similar to this:</p>
<pre><code class="language-json">{
  &quot;apps&quot;: [],
  &quot;nodes&quot;: [
    {
      &quot;id&quot;: &quot;0x6006bac77e9a7135087a60287a3ca9966f9c50a7b9ae14c2d40acc3cb31fbc56&quot;,
      &quot;tendermint_key&quot;: &quot;0x4b4432951f27c2e9a29017b3b6dee46a2e08c3a2&quot;,
      &quot;ip_addr&quot;: &quot;53.42.31.20&quot;,
      &quot;api_port&quot;: 25001,
      &quot;capacity&quot;: 10,
      &quot;owner&quot;: &quot;0x00a329c0648769a73afac7f9381e08fb43dbea72&quot;,
      &quot;is_private&quot;: false,
      &quot;clusters_ids&quot;: []
    }
  ]
}
</code></pre>
<p>Please refer to Fluence CLI <a href="../../cli/README.html">README</a> for more info on installation and usage.</p>
<a class="header" href="#private-nodes-and-application-pinning" id="private-nodes-and-application-pinning"><h2>Private nodes and application pinning</h2></a>
<a class="header" href="#private-nodes" id="private-nodes"><h3>Private nodes</h3></a>
<p>By default, after you register a node in the Fluence smart contract, any matching code could be deployed on it. So the node is publici by default.</p>
<p>But if you want to host only your app, there is a way to mark node <strong>private</strong>. That could be to be sure about what apps you're hosting, what's their workload or just to be sure <em>your</em> app gets enough resources to be ran.</p>
<p>When a node is marked as <strong>private</strong>, only your apps can be deployed on that node. This is determined by the Ethereum address that sent the transaction for node registration and for application deployment.</p>
<p>The following command will register a private node:</p>
<pre><code class="language-bash">./fluence register \
            --private \
            --node_ip               85.82.118.4 \
            --tendermint_key        1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM= \
            --tendermint_node_id    5e4eedba85fda7451356a03caffb0716e599679b \
            --contract_address      0x9995882876ae612bfd829498ccd73dd962ec950a \
            --account               0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
            --base64_tendermint_key \
            --secret_key            0xcb0799337df06a6c73881bab91304a68199a430ccd4bc378e37e51fd1b118133 \
            --wait_syncing \
            --api_port              25000 \
            --capacity              10
</code></pre>
<p>As suggested by it's name, it's the <code>--private</code> flag what's making the registered node a private one.</p>
<p>Now, only apps <a href="backend.html">published</a> to Fluence smart contract from your Ethereum address can get deployed on your nodes. <strong>But these apps need to specify nodes they should be hosted on</strong>, that's called <strong>application pinning</strong>.</p>
<a class="header" href="#application-pinning" id="application-pinning"><h3>Application pinning</h3></a>
<p>So, since your nodes are <a href="#private-nodes">private</a>, the application publishing process changes a little: you need to specify IDs of the nodes where you want the application to be hosted. With CLI, that's pretty easy. Assuming you have registered 4 private nodes, and their IDs are:</p>
<ul>
<li><code>1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM=</code></li>
<li><code>QYLcTI9uChtEVdXaR9+WgMlxJ1AVVuroe5Jyay+epbI=</code></li>
<li><code>+l30LsCMPGeL6/YIwKg8RWOhS55PLIAZT05D11GJAxY=</code></li>
<li><code>xkaW9SpCJjfzLABM+1B6PTh54qIwvgsHCkOe3VULYbE=</code></li>
</ul>
<p>All you have to do is to provide these node ids to <code>--pin_to</code> flag as a space-separated list:</p>
<pre><code class="language-bash">./fluence publish \
            --code_path        fluence/vm/examples/counter/target/wasm32-unknown-unknown/release/deps/counter.wasm \
            --contract_address 0x9995882876ae612bfd829498ccd73dd962ec950a \
            --account          0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
            --cluster_size     4 \
            --secret_key       0xcb0799337df06a6c73881bab91304a68199a430ccd4bc378e37e51fd1b118133 \
            --pin_to           1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM= \
                               QYLcTI9uChtEVdXaR9+WgMlxJ1AVVuroe5Jyay+epbI= \
                               +l30LsCMPGeL6/YIwKg8RWOhS55PLIAZT05D11GJAxY= \
                               xkaW9SpCJjfzLABM+1B6PTh54qIwvgsHCkOe3VULYbE= \
            --base64
</code></pre>
<p><em>Note that you can pin your app to your both <strong>private</strong> and <strong>public</strong> nodes.</em> Marking node as private just prevents random apps to be deployed on that node.</p>
<a class="header" href="#mixing-pinning-and-matching" id="mixing-pinning-and-matching"><h4>Mixing pinning and matching</h4></a>
<p>The command above is a perfect match, it's pinning the app to four nodes, and also specifies a cluster size of four, so every node hosting the app is directly pinned to it.</p>
<p>But what if your app requires more nodes than you wish to register? In that case, you can pin your app to any number of nodes, be it just one or a few, and specify a cluster size that you need. Fluence smart contract will then match your app both against your pinned nodes and available public nodes. The command is almost the same, except the <code>--cluster_size</code> requires eight nodes.</p>
<pre><code class="language-bash">./fluence publish \
            --code_path        /Users/folex/Development/fluence/vm/examples/counter/target/wasm32-unknown-unknown/release/deps/counter.wasm \            
            --account          0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
            --cluster_size     8 \
            --secret_key       0xcb0799337df06a6c73881bab91304a68199a430ccd4bc378e37e51fd1b118133 \
            --pin_to           1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM= \
                               QYLcTI9uChtEVdXaR9+WgMlxJ1AVVuroe5Jyay+epbI= \
                               +l30LsCMPGeL6/YIwKg8RWOhS55PLIAZT05D11GJAxY= \
                               xkaW9SpCJjfzLABM+1B6PTh54qIwvgsHCkOe3VULYbE= \
            --base64
</code></pre>
<p>So, assuming contract has just four registered nodes and one app, the <code>./fluence status --contract_address 0x9995882876ae612bfd829498ccd73dd962ec950a</code> will look like this:</p>
<pre><code class="language-json">{
  &quot;apps&quot;: [
    {
      &quot;app_id&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;,
      &quot;storage_hash&quot;: &quot;0x585114171e6b1639af3e9a4f237d8da6d1c5624b235cb45c062ca5d89a151cc2&quot;,
      &quot;storage_receipt&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
      &quot;cluster_size&quot;: 8,
      &quot;owner&quot;: &quot;0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d&quot;,
      &quot;pin_to_nodes&quot;: [
        &quot;0xd46543202ce0af0d6a6a13df49bc027d8c34cebc3dd4e319e3a4282af24c8e33&quot;,
        &quot;0x4182dc4c8f6e0a1b4455d5da47df9680c97127501556eae87b92726b2f9ea5b2&quot;,
        &quot;0xfa5df42ec08c3c678bebf608c0a83c4563a14b9e4f2c80194f4e43d751890316&quot;,
        &quot;0xc64696f52a422637f32c004cfb507a3d3879e2a230be0b070a439edd550b61b1&quot;
      ],
      &quot;cluster&quot;: null
    }
  ],
  &quot;nodes&quot;: [
    {
      &quot;id&quot;: &quot;0xd46543202ce0af0d6a6a13df49bc027d8c34cebc3dd4e319e3a4282af24c8e33&quot;,
      &quot;tendermint_key&quot;: &quot;0x5e4eedba85fda7451356a03caffb0716e599679b&quot;,
      &quot;ip_addr&quot;: &quot;85.82.118.4&quot;,
      &quot;api_port&quot;: 25000,
      &quot;capacity&quot;: 10,
      &quot;owner&quot;: &quot;0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d&quot;,
      &quot;is_private&quot;: true,
      &quot;clusters_ids&quot;: []
    },
    {
      &quot;id&quot;: &quot;0x4182dc4c8f6e0a1b4455d5da47df9680c97127501556eae87b92726b2f9ea5b2&quot;,
      &quot;tendermint_key&quot;: &quot;0x5e4eedba85fda7451356a03caffb0716e599679b&quot;,
      &quot;ip_addr&quot;: &quot;85.82.118.4&quot;,
      &quot;api_port&quot;: 25000,
      &quot;capacity&quot;: 10,
      &quot;owner&quot;: &quot;0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d&quot;,
      &quot;is_private&quot;: true,
      &quot;clusters_ids&quot;: []
    },
    {
      &quot;id&quot;: &quot;0xfa5df42ec08c3c678bebf608c0a83c4563a14b9e4f2c80194f4e43d751890316&quot;,
      &quot;tendermint_key&quot;: &quot;0x5e4eedba85fda7451356a03caffb0716e599679b&quot;,
      &quot;ip_addr&quot;: &quot;85.82.118.4&quot;,
      &quot;api_port&quot;: 25000,
      &quot;capacity&quot;: 10,
      &quot;owner&quot;: &quot;0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d&quot;,
      &quot;is_private&quot;: true,
      &quot;clusters_ids&quot;: []
    },
    {
      &quot;id&quot;: &quot;0xc64696f52a422637f32c004cfb507a3d3879e2a230be0b070a439edd550b61b1&quot;,
      &quot;tendermint_key&quot;: &quot;0x5e4eedba85fda7451356a03caffb0716e599679b&quot;,
      &quot;ip_addr&quot;: &quot;85.82.118.4&quot;,
      &quot;api_port&quot;: 25000,
      &quot;capacity&quot;: 10,
      &quot;owner&quot;: &quot;0x4180rfc65d613ba7e1a385181a219f1dbfe7bf11d&quot;,
      &quot;is_private&quot;: true,
      &quot;clusters_ids&quot;: []
    }
  ]
}
</code></pre>
<p>You see app's <code>cluster</code> is <code>null</code>, that means it's not deployed yet, waiting for enough nodes to be available.</p>
<a class="header" href="#how-to-remove-a-node-from-the-fluence-smart-contract" id="how-to-remove-a-node-from-the-fluence-smart-contract"><h2>How to remove a node from the Fluence smart contract</h2></a>
<p>If you shut down your node, it's not available anymore for any reason, or you just want to stop it hosting apps, you can remove the node from the Fluence smart contract like this:</p>
<pre><code class="language-bash">./fluence delete_node \            
            --account          0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
            --secret_key       0xcb0799337df06a6c73881bab91304a68199a430ccd4bc378e37e51fd1b118133 \
            --tendermint_key   1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM= \
            --base64_tendermint_key
</code></pre>
<a class="header" href="#tips-and-tricks-1" id="tips-and-tricks-1"><h2>Tips and tricks</h2></a>
<p>CLI has some neat features not described in that guide:</p>
<ul>
<li>Wait until your Ethereum is fully synced</li>
<li>Wait until the transaction is included in a block, printing additional info from contract</li>
<li>Look at smart contract <code>status</code> via interactive command-line table viewer</li>
</ul>
<p>All these features are described in <a href="../../cli/README.html#tips-and-tricks">CLI's readme</a>, so take a look!</p>
<ul>
<li><a href="#fluence-cli">Fluence CLI</a></li>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#usage-examples">Usage examples</a>
<ul>
<li><a href="#register-a-node">Register a node</a></li>
<li><a href="#publish-an-app">Publish an app</a>
<ul>
<li><a href="#waiting-for-an-app-to-be-deployed-or-enqueued">Waiting for an app to be deployed or enqueued</a></li>
</ul>
</li>
<li><a href="#delete-an-app">Delete an app</a></li>
<li><a href="#retrieve-fluence-network-state-as-json">Retrieve Fluence network state as JSON</a>
<ul>
<li><a href="#filtering-status">Filtering status</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#tips-and-tricks">Tips and tricks</a>
<ul>
<li><a href="#waiting-for-an-ethereum-node-to-sync">Waiting for an Ethereum node to sync</a></li>
<li><a href="#waiting-for-a-transaction-to-be-included-in-a-block">Waiting for a transaction to be included in a block</a></li>
<li><a href="#interactive-status">Interactive status</a></li>
<li><a href="#authorization-and-private-keys">Authorization and private keys</a>
<ul>
<li><a href="#keystore-json-file">Keystore JSON file</a></li>
<li><a href="#private-key">Private key</a></li>
<li><a href="#password">Password</a></li>
<li><a href="#no-authorization">No authorization</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<a class="header" href="#fluence-cli" id="fluence-cli"><h2>Fluence CLI</h2></a>
<p>Fluence CLI is an automation tool for tasks of app management (deployment and deletion), computation resource sharing (node registration), and monitoring Fluence network state (status). See usage for more info.</p>
<a class="header" href="#requirements-3" id="requirements-3"><h2>Requirements</h2></a>
<p>CLI assumes running Ethereum and Swarm on <code>http://data.fluence.one:8545/</code> and <code>http://data.fluence:8500/</code> respectively. Use <code>--eth_url</code> and <code>--storage_url</code> to specify actual addresses as you need.</p>
<p>Please note, that your Ethereum account should have sufficient funds for issuing transactions to smart-contract. It's only for transaction fees, Fluence itself doesn't currently charge miners or developers. That could change in the future, for example when miners' deposits are implemented.</p>
<p>Also, take a look at <a href="../tools/deploy/README.html">deployment scripts</a>, they will assist you in running Swarm, Ethereum and Fluence nodes.</p>
<a class="header" href="#installation-1" id="installation-1"><h2>Installation</h2></a>
<p>Requirements: <a href="https://doc.rust-lang.org/cargo/getting-started/installation.html"><code>cargo</code></a> and <a href="https://www.npmjs.com/get-npm"><code>npm</code></a> are needed.</p>
<ul>
<li>clone this repo and <code>cd</code> to <code>cli</code> folder</li>
<li>run <code>cargo build</code></li>
<li>go to <code>target/debug</code></li>
<li>there is an executable file <code>fluence</code> to work with</li>
</ul>
<a class="header" href="#usage-1" id="usage-1"><h2>Usage</h2></a>
<p>To look at all possible arguments and options use <code>./fluence --help</code>:</p>
<p>You can use <code>./fluence [SUBCOMMAND] --help</code> to learn how to use commands.</p>
<a class="header" href="#usage-examples" id="usage-examples"><h2>Usage examples</h2></a>
<a class="header" href="#setup-cli" id="setup-cli"><h3>Setup CLI</h3></a>
<p>Use <code>setup</code> command to enter main arguments into a config file. It will allow not to use common arguments in every command.</p>
<pre><code class="language-bash">./fluence setup
</code></pre>
<p>Contract address, Ethereum, and Swarm node addresses have defaults, but account address and credentials (secret key or Ethereum keystore and password) should be filled for correct transaction sending.
Arguments description and examples:</p>
<ul>
<li><code>0xeFF91455de6D4CF57C141bD8bF819E5f873c1A01</code> is a contract address, register transaction will be sent there</li>
<li><code>http://data.fluence.one:8545</code> is an URL to Ethereum node</li>
<li><code>http://data.fluence.one:8500</code> is an URL to Swarm node</li>
<li><code>0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d</code> will be used as Ethereum account for issuing transactions. <em>Use your Ethereum account here</em></li>
<li><code>0xcb0799337df06a6c73881bab91304a68199a430ccd4bc378e37e51fd1b118133</code> denotes an Ethereum private key, used for offline transaction signing. <em>Use your Ethereum private key here</em></li>
<li>it is possible to use keystore file and password instead of secret key</li>
</ul>
<p>All arguments could be overridden by flags in commands.</p>
<a class="header" href="#register-a-node" id="register-a-node"><h3>Register a node</h3></a>
<p>To provide your computation resources to Fluence network, you need to register your computer within smart-contract. The simplest way to do that is through CLI.
The following command will register a node:</p>
<pre><code>./fluence register \
            --node_ip               85.82.118.4 \
            --tendermint_key        1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM= \
            --tendermint_node_id    5e4eedba85fda7451356a03caffb0716e599679b \            
            --base64_tendermint_key \
            --wait_syncing \
            --api_port              25000 \
            --capacity              10
</code></pre>
<p>Parameters are:</p>
<ul>
<li>advertised address <code>85.82.118.4</code>, please note that this address should be available from Internet as it will be used to connect with other workers in a future cluster</li>
<li>Tendermint key (used to identify node) <code>1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM=</code>, note base64 format
<ul>
<li>flag <code>--base64_tendermint_key</code> passed so tendermint key is treated as base64-encoded as opposed to hex-encoded</li>
<li>currently, Tendermint key can be found in logs of <code>fluencelabs/node</code> Docker container</li>
<li>note that key should be unique, i.e. you can't register several nodes with the same key</li>
</ul>
</li>
<li>Tendermint p2p node ID <code>5e4eedba85fda7451356a03caffb0716e599679b</code> is needed to securely connect nodes in Tendermint cluster</li>
<li><code>--wait_syncing</code> so CLI waits until Ethereum node is fully synced</li>
<li><code>--api_port 25000</code> specifies the main port of the Fluence node, so other nodes and users know where to connect</li>
<li><code>--capacity 10</code> limits number of apps that could be run on the node by 10</li>
</ul>
<a class="header" href="#publish-an-app" id="publish-an-app"><h3>Publish an app</h3></a>
<p>To deploy your app on Fluence network, you must upload it to Swarm and publish hash to smart-contract. The simplest way to achieve that is to use CLI command <code>publish</code>.</p>
<p>The following command will publish app <code>counter.wasm</code>.</p>
<pre><code>./fluence publish \
            --code_path        fluence/vm/examples/counter/target/wasm32-unknown-unknown/release/deps/counter.wasm \                        
            --cluster_size     4 \
            --pin_to           1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM= \
            --base64
</code></pre>
<p>Interesting bits:</p>
<ul>
<li><code>--cluster_size 4</code> requires cluster of 4 workers to host this app</li>
<li><code>--pin_to 1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM= --base64</code> requires that one of the node in cluster must be <code>1GVDICzgrw1qahPfSbwCfYw0zrw91OMZ46QoKvJMjjM=</code>
<ul>
<li>note that to be used in <code>pin_to</code> node must be already registered in smart-contract</li>
</ul>
</li>
<li><code>fluence/vm/examples/counter/target/wasm32-unknown-unknown/release/deps/counter.wasm</code> is just an example path and doesn't exist in project
<ul>
<li>however, you can build it by issuing <code>sbt vm-counter/compile</code> in project root</li>
</ul>
</li>
<li>you can publish multiple wasm files in one directory.</li>
</ul>
<p>NOTE: currently maximum <code>cluster_size</code> is limited by <code>4</code>. This is to limit resource exhaustion. To use a cluster of larger size, you can <a href="../docs/src/roles/miner.html">spin up your own nodes</a>, and ping to them via <code>--pin_to</code> flag.</p>
<p>Please refer to <a href="../backend-sdk/README.html">Fluence Rust SDK</a> and <a href="../docs/src/quickstart/rust.html">Rust guide</a> to get information about developing apps with Fluence.</p>
<a class="header" href="#waiting-for-an-app-to-be-deployed-or-enqueued" id="waiting-for-an-app-to-be-deployed-or-enqueued"><h4>Waiting for an app to be deployed or enqueued</h4></a>
<p>You can pass <code>--wait</code> option to <code>publish</code> command, and CLI will wait until transaction is included in a block, and then provide you with information about app deployment status and app id.
Deployed application:</p>
<pre><code class="language-bash">[1/3]   Application code uploaded. ---&gt; [00:00:00]
swarm hash: 0x585114171e6b1639af3e9a4f237d8da6d1c5624b235cb45c062ca5d89a151cc2
[2/3]   Transaction publishing app was sent. ---&gt; [00:00:00]
  tx hash: 0xf62a8823e95804bf1f8d3832c0c49d44c7c138c1a541f9f5c0dbe7cd34056f40
[3/3]   Transaction was included. ---&gt; [00:00:00]
App deployed.
   app id: 1
  tx hash: 0xf62a8823e95804bf1f8d3832c0c49d44c7c138c1a541f9f5c0dbe7cd34056f40
</code></pre>
<p>Enqueued:</p>
<pre><code class="language-bash">[1/3]   Application code uploaded. ---&gt; [00:00:00]
swarm hash: 0x585114171e6b1639af3e9a4f237d8da6d1c5624b235cb45c062ca5d89a151cc2
[2/3]   Transaction publishing app was sent. ---&gt; [00:00:00]
  tx hash: 0x4e87150da0e273fc7d44324e6843ba9abb91413f6fb6fdce67b7f7d4a1dd320a
[3/3]   Transaction was included. ---&gt; [00:00:00]
App enqueued.
   app id: 2
  tx hash: 0x4e87150da0e273fc7d44324e6843ba9abb91413f6fb6fdce67b7f7d4a1dd320a
</code></pre>
<a class="header" href="#delete-an-app" id="delete-an-app"><h3>Delete an app</h3></a>
<p>If you want to delete your app from smart contract, you can use <code>delete_app</code> command.</p>
<p>The following will delete app with id <code>2</code>. App id could be retrieved either from status (see below) or from smart-contract.</p>
<pre><code>./fluence delete_app \
            --app_id           2 \
            --deployed
</code></pre>
<p>Note <code>--deployed</code> at the end. It means that app is deployed and cluster hosting it should be deleted as well. Without that flag, app would be removed only if there is no assigned cluster (i.e., app is not yet deployed).</p>
<p>See below on how to know if your app is deployed.</p>
<a class="header" href="#retrieve-fluence-network-state-as-json" id="retrieve-fluence-network-state-as-json"><h3>Retrieve Fluence network state as JSON</h3></a>
<p>To inspect what apps are in queue, what clusters are working out there and what nodes are participating in them, you can use <code>status</code> command as follows:</p>
<pre><code>./fluence status
</code></pre>
<p>The results will be in JSON and should resemble the following</p>
<pre><code class="language-json">{
  &quot;apps&quot;: [
    {
      &quot;app_id&quot;: &quot;1&quot;,
      &quot;storage_hash&quot;: &quot;0xeb2a623210c080d0702cc520b790151861601c46d90179a6e8efe6bda8ac5477&quot;,
      &quot;storage_receipt&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
      &quot;cluster_size&quot;: 5,
      &quot;owner&quot;: &quot;0x64b8f12d14925394ae0119466dff6ff2b021a3e9&quot;,
      &quot;pin_to_nodes&quot;: [],
      &quot;cluster&quot;: null
    },
    {
      &quot;app_id&quot;: &quot;5&quot;,
      &quot;storage_hash&quot;: &quot;0xeb2a623210c080d0702cc520b790151861601c46d90179a6e8efe6bda8ac5477&quot;,
      &quot;storage_receipt&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
      &quot;cluster_size&quot;: 5,
      &quot;owner&quot;: &quot;0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d&quot;,
      &quot;pin_to_nodes&quot;: [
        &quot;0x000000000000000000000000000000000000000000000000ef0f3348eb26bcc5&quot;,
        &quot;0x0000000000000000000000000000000000000000000000009d0b83faa72e0948&quot;,
        &quot;0x0000000000000000000000000000000000000000000000003b0222f266098324&quot;,
        &quot;0x000000000000000000000000000000000000000000000000d4cbdb932f4294d6&quot;,
        &quot;0x0000000000000000000000000000000000000000000000005aaa1fdc5999eacb&quot;
      ],
      &quot;cluster&quot;: {
        &quot;genesis_time&quot;: 1547643251,
        &quot;node_ids&quot;: [
          &quot;0x000000000000000000000000000000000000000000000000ef0f3348eb26bcc5&quot;,
          &quot;0x0000000000000000000000000000000000000000000000009d0b83faa72e0948&quot;,
          &quot;0x0000000000000000000000000000000000000000000000003b0222f266098324&quot;,
          &quot;0x000000000000000000000000000000000000000000000000d4cbdb932f4294d6&quot;,
          &quot;0x0000000000000000000000000000000000000000000000005aaa1fdc5999eacb&quot;
        ],
        &quot;ports&quot;: [
          25000,
          25002,
          25004,
          25006,
          25008
        ]
      }
    }
  ]
}
</code></pre>
<p>Here you can see two apps, the first one is enqueued (cluster is <code>null</code>) and waiting for enough nodes to host it, and the second one is already hosted on top of 5 nodes. Second app also specifies all 5 nodes in <code>pin_to_nodes</code>, and you can see the same nodes in <code>cluster.node_ids</code>.</p>
<a class="header" href="#filtering-status" id="filtering-status"><h4>Filtering status</h4></a>
<p>If you need to select specific information from status, you can use different filters:</p>
<pre><code class="language-bash">OPTIONS:
    ...
    -a, --app_id &lt;app_id&gt;                   Filter nodes and apps by app id
    -i, --node_ip &lt;ip address&gt;              Filter nodes by IP address
    -o, --owner &lt;eth address&gt;               Filter nodes and apps owned by this Ethereum address
    -K, --tendermint_key &lt;key&gt;              Filter nodes and apps by Tendermint validator key (node id)
    -f, --filter_mode &lt;and|or&gt;              Logical mode of the filter [default: and]
</code></pre>
<p>Filters work in both JSON and interactive modes. Here's an example of how they can be used:</p>
<pre><code class="language-bash">./fluence status \            
            --tendermint_key 0xb5575140febb7484393c1c99263b763d1caf6b6c83bc0a9fd6c084d2982af763 \
            --node_ip 43.32.21.10 \
            --filter_mode or
</code></pre>
<p>This will display all nodes with id <code>0xb5575140febb7484393c1c99263b763d1caf6b6c83bc0a9fd6c084d2982af763</code>, all nodes with ip <code>43.32.21.10</code> and all apps hosted by these nodes.</p>
<p>Note <code>--filter_mode or</code>, it directs CLI to match all nodes and apps that satisfy any of specified filters. You can also pass <code>--filter_mode and</code>:</p>
<pre><code class="language-bash">./fluence status \            
            --tendermint_key 0xb5575140febb7484393c1c99263b763d1caf6b6c83bc0a9fd6c084d2982af763 \
            --node_ip 43.32.21.10 \
            --filter_mode and
</code></pre>
<p>And you will get only node with id <code>0xb5575140febb7484393c1c99263b763d1caf6b6c83bc0a9fd6c084d2982af763</code> <strong>and</strong> IP <code>43.32.21.10</code>, if there is one, and all apps hosted by that node.</p>
<a class="header" href="#tips-and-tricks-2" id="tips-and-tricks-2"><h2>Tips and tricks</h2></a>
<a class="header" href="#waiting-for-an-ethereum-node-to-sync" id="waiting-for-an-ethereum-node-to-sync"><h3>Waiting for an Ethereum node to sync</h3></a>
<p>There is a flag <code>--wait_syncing</code> that, when supplied, will make CLI to wait until your Ethereum node is fully synced. It works by querying <code>eth_syncing</code> until it returns <code>false</code>.</p>
<p>This is handy when you don't want to manually check if Ethereum node is synced.</p>
<a class="header" href="#waiting-for-a-transaction-to-be-included-in-a-block" id="waiting-for-a-transaction-to-be-included-in-a-block"><h3>Waiting for a transaction to be included in a block</h3></a>
<p>There is a flag <code>--wait</code> than, when supplied, will make CLI to wait until the sent transaction is included in a block. It also parses Ethereum events (logs) related to issued command, and will print out some useful information on finish.</p>
<p>For example, when you <code>publish</code> your app, it will tell you the <code>appID</code> and if it's been deployed immediatly or enqueued to wait for enough available nodes.</p>
<p>This is easier that manually checking <code>status</code> after every command.</p>
<p>Note, however, that if you're using Ethereum node in a <strong>light mode</strong>, it can take a while until light node realizes transaction was included in a block. It can take up to several minutes (sometimes up to 10-15 minutes), so it requires some patience.</p>
<a class="header" href="#specify-contract-address" id="specify-contract-address"><h3>Specify contract address</h3></a>
<p>There is a flag <code>--contract_address</code> to use all commands to interact with non-default Fluence smart contract. You can deploy <a href="../bootstrap/contracts/Network.sol">Fluence contract</a> on your own and use CLI like this:</p>
<pre><code class="language-bash">./fluence &lt;command&gt;
            ...
            --contract_address 0xeFF91455de6D4CF57C141bD8bF819E5f873c1A01 \
            ...
</code></pre>
<a class="header" href="#interactive-status" id="interactive-status"><h3>Interactive status</h3></a>
<p>If reading raw JSON in <code>status</code> isn't the best option for you, you can use interactive status:</p>
<pre><code class="language-bash">./fluence status --interactive
</code></pre>
<p>It's just a status viewer, but it will gain more functionality in the future.</p>
<a class="header" href="#authorization-and-private-keys" id="authorization-and-private-keys"><h3>Authorization and private keys</h3></a>
<p>There are several ways to provide authorization details for your Ethereum account to Fluence CLI: via keystore JSON file, private key or password for your wallet in Ethereum node.</p>
<a class="header" href="#keystore-json-file" id="keystore-json-file"><h4>Keystore JSON file</h4></a>
<p><strong><em>This is the most secure way to provide your credentials, so it's preffered over other options</em></strong></p>
<p>That's how Geth and a few other tools export private keys. The file looks like this:</p>
<pre><code class="language-json">{&quot;address&quot;:&quot;c2d7cf95645d33006175b78989035c7c9061d3f9&quot;,
  &quot;crypto&quot;:{
    &quot;cipher&quot;:&quot;aes-128-ctr&quot;,
    &quot;ciphertext&quot;:&quot;0f6d343b2a34fe571639235fc16250823c6fe3bc30525d98c41dfdf21a97aedb&quot;,
    &quot;cipherparams&quot;:{
      &quot;iv&quot;:&quot;cabce7fb34e4881870a2419b93f6c796&quot;
    },
    &quot;kdf&quot;:&quot;scrypt&quot;,
    &quot;kdfparams&quot;: {
      &quot;dklen&quot;:32,
      &quot;n&quot;:262144,
      &quot;p&quot;:1,
      &quot;r&quot;:8,
      &quot;salt&quot;:&quot;1af9c4a44cf45fe6fb03dcc126fa56cb0f9e81463683dd6493fb4dc76edddd51&quot;
    },
    &quot;mac&quot;:&quot;5cf4012fffd1fbe41b122386122350c3825a709619224961a16e908c2a366aa6&quot;
  },
  &quot;id&quot;:&quot;eddd71dd-7ad6-4cd3-bc1a-11022f7db76c&quot;,
  &quot;version&quot;:3
}
</code></pre>
<p>It's a private key encrypted with user password. You can use it with Fluence CLI like this:</p>
<pre><code class="language-bash">./fluence SUBCOMMAND
          ...
          --account            0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
          --keystore           ~/Library/Ethereum/keystore/UTC--2017-03-03T13-24-07.826187674Z--4e6cf0ed2d8bbf1fbbc9f2a100602ceba4bf1319 \
          --passowrd           my_secure_passw0rd
</code></pre>
<p>For example, with <code>delete_app</code></p>
<pre><code class="language-bash">./fluence delete_app \            
            --account          0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
            --app_id           2 \
            --keystore         ~/Library/Ethereum/keystore/UTC--2017-03-03T13-24-07.826187674Z--4e6cf0ed2d8bbf1fbbc9f2a100602ceba4bf1319 \
            --password         my_secure_passw0rd \
            --deployed
</code></pre>
<p>Decrypted private key will be used to sign transaction in offline mode, so <strong>your key is never sent through network.</strong></p>
<a class="header" href="#private-key" id="private-key"><h4>Private key</h4></a>
<p>Other option is to provide unencrypted private key, like in most examples above:</p>
<pre><code class="language-bash">./fluence SUBCOMMAND
          ...
          --account            0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
          --secret_key         4d5db4107d237df6a3d58ee5f70ae63d73d7658d4026f2eefd2f204c81682cb7 
</code></pre>
<p>Since private key isn't encrypted, no password is required.</p>
<p>Private key will be used to sign transaction in offline mode, so <strong>your key is never sent through network.</strong></p>
<a class="header" href="#password" id="password"><h4>Password</h4></a>
<p>In case you have a <strong>trusted</strong> Ethereum node with an imported wallet, Fluence CLI can delegate signing a transaction to the Ethereum node. This can be done like this:</p>
<pre><code class="language-bash">./fluence SUBCOMMAND
          ...
          --account            0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d \
          --password           my_secure_passw0rd
</code></pre>
<p><code>personal_sendTransaction</code> will be used to send transaction. It means <strong>your password will be sent over network</strong> to the Ethereum node, and the node will sign and send transaction all by itself. It's preffered to use keystore or private key options instead of providing just a password.</p>
<p>Note, that <strong>your account is not unlocked before, in, or after that operation.</strong></p>
<a class="header" href="#no-authorization" id="no-authorization"><h4>No authorization</h4></a>
<p>It's also possible to avoid providing any credentials:</p>
<pre><code class="language-bash">./fluence SUBCOMMAND
          ...
          --account            0x4180fc65d613ba7e1a385181a219f1dbfe7bf11d
</code></pre>
<p>In that case, transaction is sent to Ethereum node via <code>eth_sendTransaction</code> unsigned, so it's expected that there is no authorization enabled on your node. <strong>This option isn't secure and was meant to be used for testing purposes.</strong></p>
<a class="header" href="#examples-1" id="examples-1"><h1>Examples</h1></a>
<p>We have provided few simple applications utilizing the Fluence network infrastructure:</p>
<ul>
<li><a href="https://github.com/fluencelabs/tutorials/tree/master/hello-world/app-sdk-rust-2018">Hello world</a> is a basic demo application demonstrating Fluence SDK usage</li>
<li><a href="https://github.com/fluencelabs/tutorials/tree/master/llamadb">Llamadb</a> is a port of an existing in-memory SQL database</li>
<li><a href="https://github.com/fluencelabs/tutorials/tree/master/tic-tac-toe">Tic-tac-toe</a> is a basic <a href="https://en.wikipedia.org/wiki/Perfect_information">perfect information</a> multi-player game</li>
<li><a href="https://github.com/fluencelabs/tutorials/tree/master/dice-game">Dice game</a> demonstrates how an RNG can be used to implement a simple gambling application</li>
<li><a href="https://github.com/fluencelabs/tutorials/tree/master/guessing-game">Guess the Number</a> is an invalid implementation of an imperfect information game (which cannot be launched on Fluence at the current moment)</li>
<li><a href="https://github.com/fluencelabs/tutorials/tree/master/streamr">Streamr analytics</a> is a simple analytics built on top of a <a href="https://www.streamr.com/">blockchain-based data marketplace</a></li>
</ul>
<a class="header" href="#project-status" id="project-status"><h1>Project status</h1></a>
<p>At the current moment, the project is under heavy development, and the architecture described in the <a href="introduction/overview.html">overview</a> is not covered completely by the deployed devnet. Below we have listed features that were already rolled out:</p>
<p><strong>+</strong> Real-time processing layer: real-time clusters with built-in BFT consensus (Tendermint)<br />
<strong>+</strong> Secure metadata storage: real-time clusters state (Ethereum)<br />
<strong>+</strong> Arbitrary code execution: WebAssembly VM (<a href="https://github.com/cretz/asmble">Asmble</a>)<br />
<strong>+</strong> SDK: frontend (JavaScript) and backend (Rust)</p>
<p>Features that have not been released yet:<br />
<strong>–</strong> Batch validation layer: tx history verification<br />
<strong>–</strong> Secure metadata storage: batch validation state, security deposits<br />
<strong>–</strong> Dispute resolution layer: verification game<br />
<strong>–</strong> Data availability layer: Swarm storage for tx history</p>
<p>We tentatively plan to let developers ingest Ethereum transactions, as well as data stored in Swarm/IPFS into Fluence to create decentralized query interfaces. We also plan that other languages such as C++ or JavaScript will be supported for backend development at some point.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-120211353-6', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
